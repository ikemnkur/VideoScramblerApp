// =============================
// UNSCRAMBLE PHOTO ENDPOINT - UPDATED VERSION
// Handles both old flat format and new nested format with noise parameters
// =============================

server.post(PROXY + '/api/unscramble-photo', upload.single('file'), async (req, res) => {
  console.log('üîì Unscramble photo request received');

  try {
    // Check if file was uploaded
    if (!req.file) {
      return res.status(400).json({ error: 'No image file provided' });
    }

    console.log('‚úÖ File uploaded:', req.file.filename);
    console.log('üìÅ File path:', req.file.path);

    // Parse parameters from request body
    let params;
    try {
      params = typeof req.body.params === 'string'
        ? JSON.parse(req.body.params)
        : req.body.params;
    } catch (parseError) {
      console.error('‚ùå Failed to parse parameters:', parseError);
      return res.status(400).json({ error: 'Invalid parameters format' });
    }

    console.log('üìã Unscrambling parameters (from frontend):', params);

    // Check if params has nested structure (new format) or flat structure (old format)
    let scrambleParams = params;
    let noiseParams = null;
    let metadata = null;

    if (params.scramble) {
      // New nested format
      scrambleParams = params.scramble;
      noiseParams = params.noise;
      metadata = params.metadata;
      console.log('üÜï Detected new nested parameter format');
    } else {
      // Old flat format - for backwards compatibility
      console.log('üì¶ Using legacy flat parameter format');
    }

    // Prepare data to send to Flask
    const flaskPayload = {
      input: req.file.filename,
      output: `unscrambled_${req.file.filename}`,
      seed: scrambleParams.seed ?? params.seed,
      mode: 'unscramble',
      algorithm: scrambleParams.algorithm ?? params.algorithm,
      percentage: scrambleParams.percentage ?? params.percentage ?? 100,
      // Algorithm-specific params (check both nested and flat structure)
      rows: scrambleParams.rows ?? params.rows,
      cols: scrambleParams.cols ?? params.cols,
      max_hue_shift: scrambleParams.max_hue_shift ?? scrambleParams.maxHueShift ?? params.max_hue_shift ?? params.maxHueShift,
      max_intensity_shift: scrambleParams.max_intensity_shift ?? scrambleParams.maxIntensityShift ?? params.max_intensity_shift ?? params.maxIntensityShift,
      // Noise parameters (if present)
      noise_seed: noiseParams?.seed,
      noise_intensity: noiseParams?.intensity,
      noise_mode: noiseParams?.mode,
      noise_prng: noiseParams?.prng
    };

    // Remove undefined keys so Flask doesn't see them at all
    Object.keys(flaskPayload).forEach((key) => {
      if (flaskPayload[key] === undefined) delete flaskPayload[key];
    });

    // Log noise parameters if present
    if (noiseParams) {
      console.log('üîä Noise parameters detected:', {
        seed: noiseParams.seed,
        intensity: noiseParams.intensity,
        mode: noiseParams.mode
      });
    }

    console.log('üîÑ Sending normalized payload to Flask:', flaskPayload);
    console.log('üîÑ Sending to Flask service:', FLASKAPP_LINK + '/unscramble-photo');

    // Send request to Flask/Python service
    const flaskResponse = await axios.post(
      `${FLASKAPP_LINK}/unscramble-photo`,
      flaskPayload,
      {
        timeout: 30000, // 30 second timeout
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );

    console.log('‚úÖ Flask response received:', flaskResponse.data);

    // Return Flask response to frontend with noise parameters included
    res.json({
      success: true,
      output_file: flaskResponse.data.output_file || flaskResponse.data.unscrambledFileName,
      unscrambledImageUrl: flaskResponse.data.unscrambledImageUrl,
      message: 'Image unscrambled successfully',
      // Include noise parameters so frontend knows to remove noise
      noise: noiseParams ? {
        seed: noiseParams.seed,
        intensity: noiseParams.intensity,
        mode: noiseParams.mode,
        prng: noiseParams.prng
      } : undefined,
      // Include metadata if present
      metadata: metadata,
      ...flaskResponse.data
    });

  } catch (error) {
    console.error('‚ùå Error in unscramble-photo endpoint:', error.message);

    // Clean up uploaded file if processing failed
    if (req.file && fs.existsSync(req.file.path)) {
      try {
        fs.unlinkSync(req.file.path);
        console.log('üóëÔ∏è  Cleaned up failed upload:', req.file.filename);
      } catch (unlinkError) {
        console.error('Failed to delete file:', unlinkError);
      }
    }

    if (error.code === 'ECONNREFUSED') {
      return res.status(503).json({
        error: 'Python/Flask service is not running. Please start the Flask server on port 5000.'
      });
    }

    if (error.response) {
      // Flask returned an error
      return res.status(error.response.status || 500).json({
        error: error.response.data?.error || 'Unscrambling failed in Python service',
        details: error.response.data
      });
    }

    res.status(500).json({
      error: 'Failed to unscramble photo',
      message: error.message
    });
  }
});

// =============================
// KEY CHANGES SUMMARY:
// =============================
// 1. Added detection for nested parameter format (params.scramble, params.noise, params.metadata)
// 2. Maintains backward compatibility with old flat format
// 3. Extracts noise parameters if present: seed, intensity, mode, prng
// 4. Passes noise parameters to Flask (as noise_seed, noise_intensity, etc.)
// 5. Includes noise parameters in response back to frontend for client-side noise removal
// 6. Handles both camelCase (maxHueShift) and snake_case (max_hue_shift) for flexibility
// 7. Logs noise parameters when present for debugging
// 
// IMPORTANT: The frontend must remove noise from the unscrambled image after receiving it
// from the backend, as the noise was applied BEFORE scrambling in the Pro version.
