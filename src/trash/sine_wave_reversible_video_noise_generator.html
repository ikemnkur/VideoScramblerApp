<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Seeded Sine Wave Video Scrambler (Reversible)</title>
    <style>
        :root {
            --bg: #0b1220;
            --card: #0f1b33;
            --muted: #9fb0cc;
            --text: #eaf1ff;
            --accent: #66e3ff;
            --border: #1f335a;
            --good: #64ffb8;
            --warn: #ffcc66;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
            background: radial-gradient(1200px 600px at 20% 0%, #12224a 0%, var(--bg) 60%);
            color: var(--text);
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px
        }

        h1 {
            margin: 6px 0 16px;
            font-size: 22px
        }

        h2 {
            margin: 0 0 10px;
            font-size: 16px;
            color: #d9e6ff
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 14px
        }

        @media (min-width: 980px) {
            .grid {
                grid-template-columns: 1fr 1fr
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .03));
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 14px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, .35);
            backdrop-filter: blur(6px);
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        .row>* {
            flex: 0 0 auto
        }

        label {
            font-size: 12px;
            color: var(--muted)
        }

        input[type="file"] {
            max-width: 100%
        }

        input[type="number"],
        input[type="text"],
        textarea {
            background: #0b1733;
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 10px;
            padding: 9px 10px;
            outline: none;
        }

        textarea {
            width: 100%;
            min-height: 92px;
            resize: vertical;
            line-height: 1.3
        }

        .btn {
            border: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(102, 227, 255, .18), rgba(102, 227, 255, .08));
            color: var(--text);
            border-radius: 12px;
            padding: 9px 12px;
            cursor: pointer;
            transition: transform .05s ease;
            user-select: none;
        }

        .btn:active {
            transform: translateY(1px)
        }

        .btn.secondary {
            background: linear-gradient(180deg, rgba(255, 255, 255, .10), rgba(255, 255, 255, .05));
        }

        .btn.ghost {
            background: transparent;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pill {
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--muted);
            background: rgba(0, 0, 0, .15);
        }

        .sliderWrap {
            display: flex;
            align-items: center;
            gap: 8px
        }

        input[type="range"] {
            width: 240px
        }

        .kv {
            display: grid;
            grid-template-columns: 140px 1fr;
            gap: 8px 10px;
            margin-top: 10px;
            font-size: 12px;
            color: var(--muted);
        }

        .kv div:nth-child(2n) {
            color: var(--text)
        }

        .videoRow {
            display: grid;
            gap: 10px;
            grid-template-columns: 1fr
        }

        @media (min-width: 980px) {
            .videoRow {
                grid-template-columns: 1fr 1fr
            }
        }

        video,
        canvas {
            width: 100%;
            background: #081027;
            border: 1px solid var(--border);
            border-radius: 14px;
        }

        .hint {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px
        }

        .status {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px
        }

        .status b {
            color: var(--good)
        }

        .warn b {
            color: var(--warn)
        }

        code.inline {
            background: rgba(0, 0, 0, .25);
            border: 1px solid var(--border);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 12px;
            color: #d8e6ff;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #0b1733;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--good));
            transition: width 0.3s ease;
            width: 0%;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>Seeded Low-Frequency Sine Wave Video Scrambler (Reversible Add/Sub Mod 256)</h1>

        <div class="grid">

            <!-- =========================
           Forward / Add Sine Wave Pattern
      ========================== -->
            <section class="card">
                <h2>1) Add sine wave pattern to video (forward)</h2>

                <div class="row">
                    <div>
                        <label>Upload video</label><br />
                        <input id="inOriginal" type="file" accept="video/*" />
                    </div>
                </div>

                <div style="height:10px"></div>

                <div class="row">
                    <div>
                        <label>Seed (32-bit integer)</label><br />
                        <div class="row">
                            <input id="seed" type="number" step="1" value="123456789" style="width:220px" />
                            <button id="btnRandomSeed" class="btn secondary">Random seed</button>
                        </div>
                    </div>

                    <div>
                        <label>Sine wave intensity (64-128 luminance offset)</label><br />
                        <div class="sliderWrap">
                            <button id="btnIntMinus" class="btn ghost">−</button>
                            <input id="intensity" type="range" min="64" max="128" value="96" />
                            <button id="btnIntPlus" class="btn ghost">+</button>
                            <input id="intensityNum" type="number" min="64" max="128" value="96" style="width:80px" />
                        </div>
                    </div>
                </div>

                <div style="height:10px"></div>

                <div class="row">
                    <div>
                        <label>Tile scale factor (smaller = more compression-resistant)</label><br />
                        <div class="sliderWrap">
                            <input id="tileScale" type="range" min="8" max="128" value="8" step="1" />
                            <input id="tileScaleNum" type="number" min="8" max="128" value="8" style="width:80px" />
                        </div>
                        <div class="hint" style="margin-top:4px">Video dimensions will be divided by this factor to
                            create the noise tile</div>
                    </div>
                </div>

                <div style="height:10px"></div>

                <div class="row">
                    <button id="btnAddNoise" class="btn">Generate + Apply sine waves</button>
                    <button id="btnDownloadNoisy" class="btn secondary" disabled>Download scrambled video</button>
                    <span class="pill" id="tileInfo">Waves: —</span>
                </div>

                <div class="progress-bar" id="progressBarForward" style="display:none">
                    <div class="progress-fill" id="progressFillForward"></div>
                </div>

                <div class="kv" id="paramsKv" style="display:none">
                    <!-- filled by JS -->
                </div>

                <div class="row" style="margin-top:10px">
                    <button id="btnCopyParams" class="btn secondary" disabled>Copy parameters</button>
                    <input id="paramsText" type="text" readonly style="flex:1 1 420px; min-width:280px" />
                </div>
                <div class="hint">
                    Parameters include the video dimensions, seed, intensity, sine wave count, and algorithm version.
                    Keep them with the scrambled video to reverse it later. Luminance-only sine waves eliminate color
                    banding and are highly resistant to video compression.
                </div>

                <div style="height:10px"></div>

                <div class="videoRow">
                    <div>
                        <label>Original video</label>
                        <video id="videoOriginal" controls muted></video>
                    </div>
                    <div>
                        <label>Scrambled output preview</label>
                        <canvas id="cvNoisy"></canvas>
                    </div>
                </div>

                <div style="height:10px"></div>

                <div class="videoRow">
                    <div>
                        <label>Sine wave pattern preview (visualized as 128 + offset)</label>
                        <canvas id="cvNoiseTile"></canvas>
                    </div>
                    <div>
                        <label>Sine wave pattern (zoomed)</label>
                        <canvas id="cvNoiseTileZoom"></canvas>
                    </div>
                </div>

                <div class="status" id="statusForward">Status: —</div>
            </section>

            <!-- =========================
           Reverse / Restore
      ========================== -->
            <section class="card">
                <h2>2) Reverse sine waves (restore video)</h2>

                <div class="row">
                    <div>
                        <label>Upload scrambled video</label><br />
                        <input id="inNoisy" type="file" accept="video/*" />
                    </div>
                </div>

                <div style="height:10px"></div>

                <label>Paste parameters (copied from above)</label>
                <textarea id="paramsPaste"
                    placeholder='{"v":2,"w":1920,"h":1080,"tileW":240,"tileH":135,"scale":8,"seed":123,"intensity":24,"mode":"add_mod256_scaled","prng":"mulberry32","fps":30,"duration":5.2,"note":"..."}'></textarea>

                <div class="row" style="margin-top:10px">
                    <button id="btnRestore" class="btn">Restore (reverse noise)</button>
                    <button id="btnDownloadRestored" class="btn secondary" disabled>Download restored video</button>
                    <span class="pill" id="restoreInfo">—</span>
                </div>

                <div class="progress-bar" id="progressBarRestore" style="display:none">
                    <div class="progress-fill" id="progressFillRestore"></div>
                </div>

                <div class="hint">
                    Restore is done by regenerating the same sine wave pattern from the parameters, then
                    applying modulo subtraction (i.e., reverse of the forward pass) to each frame.
                </div>

                <div style="height:10px"></div>

                <div class="videoRow">
                    <div>
                        <label>Scrambled input</label>
                        <video id="videoNoisyIn" controls muted></video>
                    </div>
                    <div>
                        <label>Restored output preview</label>
                        <canvas id="cvRestored"></canvas>
                    </div>
                </div>

                <div style="height:10px"></div>

                <div class="videoRow">
                    <div>
                        <label>Regenerated sine wave pattern preview</label>
                        <canvas id="cvNoiseTile2"></canvas>
                    </div>
                    <div>
                        <label>Regenerated sine wave pattern (zoomed)</label>
                        <canvas id="cvNoiseTileZoom2"></canvas>
                    </div>
                </div>

                <div class="status" id="statusRestore">Status: —</div>
            </section>

        </div>

        <div class="hint" style="margin-top:14px">
            Implementation notes:
            <span class="inline code inline">scrambled = (orig + offset) mod 256</span>,
            <span class="inline code inline">restored = (scrambled - offset) mod 256</span>.
            Low-frequency sine wave pattern is generated using 2-6 sine waves along X and Y axes, with luminance-only
            offsets (64-128).
            The same offset is applied to R, G, B channels equally, eliminating color banding artifacts.
            This approach is highly resistant to compression artifacts since sine waves contain only low-frequency
            components. Applied frame-by-frame.
        </div>
    </div>

    <script>
        /* =========================
           Utilities
        ========================= */
        function gcd(a, b) {
            a = Math.abs(a | 0); b = Math.abs(b | 0);
            while (b !== 0) { const t = a % b; a = b; b = t; }
            return a;
        }

        function mod(n, m) {
            // true mathematical modulo for negatives
            return ((n % m) + m) % m;
        }

        // Mulberry32 PRNG (seeded, fast, deterministic)
        function mulberry32(seed) {
            let t = seed >>> 0;
            return function () {
                t += 0x6D2B79F5;
                let x = Math.imul(t ^ (t >>> 15), 1 | t);
                x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
                return ((x ^ (x >>> 14)) >>> 0) / 4294967296; // [0,1)
            };
        }

        function clampInt(n, lo, hi) {
            n = Number(n);
            if (!Number.isFinite(n)) n = lo;
            return Math.max(lo, Math.min(hi, Math.round(n)));
        }

        /* =========================
           Sine wave pattern generation (low-frequency, luminance-only)
           - Generate 2-6 sine waves along X and Y axes
           - Each wave affects luminance equally across all channels (no color artifacts)
           - Smooth, compression-resistant pattern
        ========================= */
        function generateSineWavePattern(w, h, seed, intensity) {
            const rand = mulberry32(seed >>> 0);

            // Determine number of sine waves (2-6)
            const numWaves = Math.floor(rand() * 5) + 2; // 2-6 waves

            // Generate wave parameters
            const waves = [];
            for (let i = 0; i < numWaves; i++) {
                const direction = rand() < 0.5 ? 'x' : 'y'; // Along X or Y axis
                const frequency = rand() * 0.5 + 0.3; // Low frequency: 0.3-0.8 cycles per dimension
                const phase = rand() * Math.PI * 2; // Random phase shift

                // Amplitude for this wave (intensity range)
                const waveIntensity = rand() * (intensity - 64) + 64;
                const polarity = rand() < 0.5 ? 1 : -1; // Random positive/negative

                waves.push({
                    direction,
                    frequency,
                    phase,
                    amplitude: waveIntensity * polarity
                });
            }

            // Generate offset pattern (single luminance value per pixel)
            const offsets = new Int16Array(w * h);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;

                    let luminanceOffset = 0;

                    // Sum contributions from all sine waves
                    for (const wave of waves) {
                        const coord = wave.direction === 'x' ? x / w : y / h;
                        const sineValue = Math.sin(coord * Math.PI * 2 * wave.frequency + wave.phase);

                        luminanceOffset += sineValue * wave.amplitude;
                    }

                    // Store rounded integer offset (same for R, G, B)
                    offsets[idx] = Math.round(luminanceOffset);
                }
            }

            return { offsets, waves, numWaves };
        }

        // Visualize offsets as grayscale around 128 (so 0 offset = mid-gray)
        function renderPatternPreview(patternOffsets, w, h, cv, zoom = 1) {
            cv.width = w * zoom;
            cv.height = h * zoom;

            const tmp = document.createElement("canvas");
            tmp.width = w; tmp.height = h;
            const tctx = tmp.getContext("2d", { willReadFrequently: true });
            const img = tctx.createImageData(w, h);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const p = (y * w + x);
                    const i = p * 4;

                    // Single luminance offset applied to all channels
                    const gray = 128 + patternOffsets[p];

                    img.data[i + 0] = clampInt(gray, 0, 255);
                    img.data[i + 1] = clampInt(gray, 0, 255);
                    img.data[i + 2] = clampInt(gray, 0, 255);
                    img.data[i + 3] = 255;
                }
            }
            tctx.putImageData(img, 0, 0);

            const ctx = cv.getContext("2d");
            ctx.imageSmoothingEnabled = true; // Enable smoothing for sine waves
            ctx.clearRect(0, 0, cv.width, cv.height);
            ctx.drawImage(tmp, 0, 0, cv.width, cv.height);
        }

        function applyNoiseAddMod256(imageData, patternOffsets) {
            const w = imageData.width, h = imageData.height;
            const src = imageData.data;
            const out = new Uint8ClampedArray(src); // copy

            // Apply luminance offset to all RGB channels equally (prevents color banding)
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const patternIdx = y * w + x;
                    const i = (y * w + x) * 4;

                    // Same offset for R, G, B channels
                    const offset = patternOffsets[patternIdx];

                    out[i + 0] = mod(src[i + 0] + offset, 256);
                    out[i + 1] = mod(src[i + 1] + offset, 256);
                    out[i + 2] = mod(src[i + 2] + offset, 256);
                    // alpha unchanged
                }
            }

            return new ImageData(out, w, h);
        }

        function applyNoiseSubMod256(imageData, patternOffsets) {
            const w = imageData.width, h = imageData.height;
            const src = imageData.data;
            const out = new Uint8ClampedArray(src); // copy

            // Apply inverse luminance offset to all RGB channels equally
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const patternIdx = y * w + x;
                    const i = (y * w + x) * 4;

                    // Same offset for R, G, B channels
                    const offset = patternOffsets[patternIdx];

                    out[i + 0] = mod(src[i + 0] - offset, 256);
                    out[i + 1] = mod(src[i + 1] - offset, 256);
                    out[i + 2] = mod(src[i + 2] - offset, 256);
                }
            }
            return new ImageData(out, w, h);
        }
        //   }
        //   return new ImageData(out, w, h);
        // }

        /* =========================
           Video Processing
        ========================= */
        async function processVideo(videoElement, patternOffsets, mode, progressCallback) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });

                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;

                const stream = canvas.captureStream(30); // 30 fps

                // Choose a mimeType that the browser supports with fallback mechanism
                let mediaRecorder;
                try {
                    const preferred = [
                        "video/webm;codecs=vp9",
                        "video/webm;codecs=vp8",
                        "video/webm;codecs=vp8,opus",
                        "video/webm"
                    ];
                    let opts = { videoBitsPerSecond: 8000000 }; // 8 Mbps

                    for (const mt of preferred) {
                        try {
                            if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mt)) {
                                opts.mimeType = mt;
                                break;
                            }
                        } catch (e) {
                            // ignore and try next
                        }
                    }

                    // If no supported mimeType was found, use default options
                    mediaRecorder = new MediaRecorder(stream, opts);
                } catch (err) {
                    // As a last-resort fallback, try without mimeType specification
                    try {
                        mediaRecorder = new MediaRecorder(stream, { videoBitsPerSecond: 8000000 });
                    } catch (finalErr) {
                        reject(new Error("Recording not supported in this browser: " + finalErr.message));
                        return;
                    }
                }

                const chunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    resolve(blob);
                };

                mediaRecorder.onerror = (e) => {
                    reject(new Error('MediaRecorder error: ' + e));
                };

                // Start recording
                mediaRecorder.start();

                let frameCount = 0;
                const totalFrames = Math.ceil(videoElement.duration * 30); // estimate

                videoElement.currentTime = 0;

                function processFrame() {
                    if (videoElement.ended || videoElement.paused) {
                        mediaRecorder.stop();
                        return;
                    }

                    // Draw current frame
                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

                    // Get image data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Apply sine wave pattern
                    let processed;
                    if (mode === 'add') {
                        processed = applyNoiseAddMod256(imageData, patternOffsets);
                    } else {
                        processed = applyNoiseSubMod256(imageData, patternOffsets);
                    }

                    // Put processed frame back
                    ctx.putImageData(processed, 0, 0);

                    frameCount++;
                    if (progressCallback) {
                        progressCallback(frameCount / totalFrames);
                    }

                    // Continue to next frame
                    requestAnimationFrame(processFrame);
                }

                videoElement.play();
                requestAnimationFrame(processFrame);
            });
        }

        function downloadBlob(blob, filename) {
            const a = document.createElement("a");
            const url = URL.createObjectURL(blob);
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(url), 0);
        }

        /* =========================
           DOM wiring
        ========================= */
        const el = (id) => document.getElementById(id);

        const inOriginal = el("inOriginal");
        const inNoisy = el("inNoisy");

        const seedInput = el("seed");
        const btnRandomSeed = el("btnRandomSeed");

        const intensityRange = el("intensity");
        const intensityNum = el("intensityNum");
        const btnIntMinus = el("btnIntMinus");
        const btnIntPlus = el("btnIntPlus");

        const tileScaleRange = el("tileScale");
        const tileScaleNum = el("tileScaleNum");

        const btnAddNoise = el("btnAddNoise");
        const btnCopyParams = el("btnCopyParams");
        const paramsText = el("paramsText");
        const paramsKv = el("paramsKv");
        const tileInfo = el("tileInfo");
        const statusForward = el("statusForward");
        const btnDownloadNoisy = el("btnDownloadNoisy");

        const videoOriginal = el("videoOriginal");
        const cvNoisy = el("cvNoisy");
        const cvNoiseTile = el("cvNoiseTile");
        const cvNoiseTileZoom = el("cvNoiseTileZoom");

        const progressBarForward = el("progressBarForward");
        const progressFillForward = el("progressFillForward");

        const paramsPaste = el("paramsPaste");
        const btnRestore = el("btnRestore");
        const restoreInfo = el("restoreInfo");
        const statusRestore = el("statusRestore");
        const btnDownloadRestored = el("btnDownloadRestored");

        const videoNoisyIn = el("videoNoisyIn");
        const cvRestored = el("cvRestored");
        const cvNoiseTile2 = el("cvNoiseTile2");
        const cvNoiseTileZoom2 = el("cvNoiseTileZoom2");

        const progressBarRestore = el("progressBarRestore");
        const progressFillRestore = el("progressFillRestore");

        let forwardState = {
            videoFile: null,
            noisyBlob: null,
            params: null,
        };

        let restoreState = {
            videoFile: null,
            restoredBlob: null,
            params: null,
        };

        function syncIntensity(from) {
            if (from === "range") {
                intensityNum.value = intensityRange.value;
            } else if (from === "num") {
                intensityRange.value = clampInt(intensityNum.value, 64, 128);
                intensityNum.value = intensityRange.value;
            }
        }
        intensityRange.addEventListener("input", () => syncIntensity("range"));
        intensityNum.addEventListener("input", () => syncIntensity("num"));

        function syncTileScale(from) {
            if (from === "range") {
                tileScaleNum.value = tileScaleRange.value;
            } else if (from === "num") {
                tileScaleRange.value = clampInt(tileScaleNum.value, 8, 128);
                tileScaleNum.value = tileScaleRange.value;
            }
        }
        tileScaleRange.addEventListener("input", () => syncTileScale("range"));
        tileScaleNum.addEventListener("input", () => syncTileScale("num"));

        btnIntMinus.addEventListener("click", () => {
            intensityRange.value = clampInt(Number(intensityRange.value) - 1, 64, 128);
            syncIntensity("range");
        });
        btnIntPlus.addEventListener("click", () => {
            intensityRange.value = clampInt(Number(intensityRange.value) + 1, 64, 128);
            syncIntensity("range");
        });

        btnRandomSeed.addEventListener("click", () => {
            const u = new Uint32Array(1);
            crypto.getRandomValues(u);
            seedInput.value = (u[0] >>> 0);
        });

        inOriginal.addEventListener("change", async () => {
            forwardState.videoFile = null;
            forwardState.noisyBlob = null;
            forwardState.params = null;
            paramsText.value = "";
            paramsKv.style.display = "none";
            btnCopyParams.disabled = true;
            btnDownloadNoisy.disabled = true;

            const file = inOriginal.files?.[0];
            if (!file) return;

            forwardState.videoFile = file;
            const url = URL.createObjectURL(file);
            videoOriginal.src = url;

            videoOriginal.onloadedmetadata = () => {
                const w = videoOriginal.videoWidth;
                const h = videoOriginal.videoHeight;
                const duration = videoOriginal.duration;

                cvNoisy.width = w;
                cvNoisy.height = h;

                tileInfo.textContent = `Ready: ${w}×${h}`;
                statusForward.textContent = `Status: Loaded original (${w}×${h}, ${duration.toFixed(2)}s).`;
            };
        });

        inNoisy.addEventListener("change", async () => {
            restoreState.videoFile = null;
            restoreState.restoredBlob = null;
            restoreState.params = null;
            btnDownloadRestored.disabled = true;

            const file = inNoisy.files?.[0];
            if (!file) return;

            restoreState.videoFile = file;
            const url = URL.createObjectURL(file);
            videoNoisyIn.src = url;

            videoNoisyIn.onloadedmetadata = () => {
                const w = videoNoisyIn.videoWidth;
                const h = videoNoisyIn.videoHeight;
                const duration = videoNoisyIn.duration;

                cvRestored.width = w;
                cvRestored.height = h;

                statusRestore.textContent = `Status: Loaded scrambled (${w}×${h}, ${duration.toFixed(2)}s). Paste params and click Restore.`;
            };
        });

        // btnAddNoise.addEventListener("click", async () => {
        //   try {
        //     if (!forwardState.videoFile) {
        //       statusForward.textContent = "Status: Please upload a video first.";
        btnAddNoise.addEventListener("click", async () => {
            try {
                if (!forwardState.videoFile) {
                    statusForward.textContent = "Status: Please upload a video first.";
                    return;
                }

                const w = videoOriginal.videoWidth;
                const h = videoOriginal.videoHeight;
                const duration = videoOriginal.duration;
                const seed = (Number(seedInput.value) >>> 0);
                const intensity = clampInt(intensityRange.value, 64, 128);

                // Generate sine wave pattern
                const { offsets: patternOffsets, waves, numWaves } = generateSineWavePattern(w, h, seed, intensity);

                // Render pattern previews (downsampled for display)
                const previewW = Math.min(w, 640);
                const previewH = Math.min(h, 360);
                const previewScale = Math.max(w / previewW, h / previewH);

                // Generate preview at lower resolution
                const { offsets: previewOffsets } = generateSineWavePattern(previewW, previewH, seed, intensity);
                renderPatternPreview(previewOffsets, previewW, previewH, cvNoiseTile, 1);
                renderPatternPreview(previewOffsets, previewW, previewH, cvNoiseTileZoom, 2);

                btnAddNoise.disabled = true;
                progressBarForward.style.display = "block";
                statusForward.textContent = "Status: Processing video with sine waves...";

                // Process video
                const noisyBlob = await processVideo(
                    videoOriginal,
                    patternOffsets,
                    'add',
                    (progress) => {
                        progressFillForward.style.width = (progress * 100) + '%';
                    }
                );

                forwardState.noisyBlob = noisyBlob;

                // Draw preview frame
                videoOriginal.currentTime = 0;
                await new Promise(resolve => {
                    videoOriginal.onseeked = () => {
                        const ctx = cvNoisy.getContext('2d', { willReadFrequently: true });
                        ctx.drawImage(videoOriginal, 0, 0, w, h);
                        const imageData = ctx.getImageData(0, 0, w, h);
                        const processed = applyNoiseAddMod256(imageData, patternOffsets);
                        ctx.putImageData(processed, 0, 0);

                        resolve();
                    };
                });


                // Store params
                const params = {
                    v: 4,
                    mode: "add_mod256_sinewaves_luminance",
                    prng: "mulberry32",
                    w, h,
                    seed,
                    intensity,
                    numWaves,
                    fps: 30,
                    duration: duration,
                    note: "Keep these params with the scrambled video to reverse it. Luminance-only sine waves eliminate color banding and provide maximum compression resistance."
                };

                forwardState.params = params;

                // Show params + copy
                const paramsStr = JSON.stringify(params);
                paramsText.value = paramsStr;
                btnCopyParams.disabled = false;
                btnDownloadNoisy.disabled = false;
                btnAddNoise.disabled = false;

                // Show key-values
                paramsKv.innerHTML = `
      <div>Version</div><div>${params.v}</div>
      <div>Mode</div><div>${params.mode}</div>
      <div>PRNG</div><div>${params.prng}</div>
      <div>Video</div><div>${params.w}×${params.h}</div>
      <div>Duration</div><div>${params.duration.toFixed(2)}s @ ${params.fps} fps</div>
      <div>Sine Waves</div><div>${params.numWaves} waves</div>
      <div>Seed</div><div>${params.seed}</div>
      <div>Intensity</div><div>${params.intensity}</div>
    `;
                paramsKv.style.display = "grid";

                tileInfo.textContent = `Waves: ${numWaves} sine waves`;
                statusForward.innerHTML = `Status: <b>Applied sine waves</b> (seed=${seed}, intensity=${intensity}, ${numWaves} waves).`;
                progressBarForward.style.display = "none";
                progressFillForward.style.width = "0%";
            } catch (e) {
                statusForward.textContent = `Status: Error: ${e?.message || e}`;
                btnAddNoise.disabled = false;
                progressBarForward.style.display = "none";
            }

        });

        btnCopyParams.addEventListener("click", async () => {
            try {
                if (!paramsText.value) return;
                await navigator.clipboard.writeText(paramsText.value);
                statusForward.innerHTML = `Status: <b>Copied</b> parameters to clipboard.`;
            } catch (e) {
                statusForward.textContent = `Status: Could not copy (browser permission). You can still manually copy the text.`;
            }
        });

        btnDownloadNoisy.addEventListener("click", async () => {
            if (!forwardState.noisyBlob) return;
            downloadBlob(forwardState.noisyBlob, "scrambled_video.webm");
        });
        btnRestore.addEventListener("click", async () => {
            try {
                if (!restoreState.videoFile) {
                    statusRestore.textContent = "Status: Please upload a scrambled video first.";
                    return;
                }
                const raw = paramsPaste.value.trim();
                if (!raw) {
                    statusRestore.textContent = "Status: Please paste the parameters JSON.";
                    return;
                }

                let params;
                try {
                    params = JSON.parse(raw);
                } catch {
                    statusRestore.textContent = "Status: Parameters are not valid JSON.";
                    return;
                }

                const w = videoNoisyIn.videoWidth;
                const h = videoNoisyIn.videoHeight;
                const duration = videoNoisyIn.duration;

                const seed = (Number(params.seed) >>> 0);
                const intensity = clampInt(params.intensity, 64, 128);

                if (w !== params.w || h !== params.h) {
                    statusRestore.classList.add("warn");
                } else {
                    statusRestore.classList.remove("warn");
                }

                // Regenerate sine wave pattern deterministically
                const { offsets: patternOffsets, numWaves } = generateSineWavePattern(w, h, seed, intensity);

                // Show regenerated pattern previews (downsampled for display)
                const previewW = Math.min(w, 640);
                const previewH = Math.min(h, 360);
                const { offsets: previewOffsets } = generateSineWavePattern(previewW, previewH, seed, intensity);
                renderPatternPreview(previewOffsets, previewW, previewH, cvNoiseTile2, 1);
                renderPatternPreview(previewOffsets, previewW, previewH, cvNoiseTileZoom2, 2);

                btnRestore.disabled = true;
                progressBarRestore.style.display = "block";
                statusRestore.textContent = "Status: Processing video...";

                // Process video
                const restoredBlob = await processVideo(
                    videoNoisyIn,
                    patternOffsets,
                    'sub',
                    (progress) => {
                        progressFillRestore.style.width = (progress * 100) + '%';
                    }
                );

                restoreState.restoredBlob = restoredBlob;

                // Draw preview frame
                videoNoisyIn.currentTime = 0;
                await new Promise(resolve => {
                    videoNoisyIn.onseeked = () => {
                        const ctx = cvRestored.getContext('2d', { willReadFrequently: true });
                        ctx.drawImage(videoNoisyIn, 0, 0, w, h);
                        const imageData = ctx.getImageData(0, 0, w, h);
                        const processed = applyNoiseSubMod256(imageData, patternOffsets);
                        ctx.putImageData(processed, 0, 0);
                        resolve();
                    };
                });

                restoreState.params = { ...params, w, h, seed, intensity, numWaves };

                btnDownloadRestored.disabled = false;
                btnRestore.disabled = false;
                restoreInfo.textContent = `Restore: seed=${seed}, intensity=${intensity}, ${numWaves} waves`;
                statusRestore.innerHTML = `Status: <b>Restored</b> via modulo subtraction. ${((w !== params.w) || (h !== params.h)) ? "(Warning: video dims differ from params; used best-effort.)" : ""}`;
                progressBarRestore.style.display = "none";
                progressFillRestore.style.width = "0%";
            } catch (e) {
                statusRestore.textContent = `Status: Error: ${e?.message || e}`;
                btnRestore.disabled = false;
                progressBarRestore.style.display = "none";
            }
        });

        btnDownloadRestored.addEventListener("click", async () => {
            if (!restoreState.restoredBlob) return;
            downloadBlob(restoreState.restoredBlob, "restored_video.webm");
        });
    </script>
</body>

</html>