<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Image Transform Fingerprint Lab - Crop Test (A + B → C; A + C → B)</title>
    <style>
        :root {
            --bg: #0b1220;
            --card: #0f1b33;
            --muted: #a7b3cc;
            --text: #e9eefc;
            --border: rgba(255, 255, 255, .10);
            --accent: #7dd3fc;
            --accent2: #a78bfa;
            --good: #34d399;
            --warn: #fbbf24;
            --bad: #fb7185;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
            background: radial-gradient(1200px 700px at 20% -10%, rgba(125, 211, 252, .18), transparent 60%),
                radial-gradient(1000px 600px at 120% 20%, rgba(167, 139, 250, .16), transparent 55%),
                linear-gradient(180deg, #070b14, var(--bg));
            color: var(--text);
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 22px;
        }

        h1 {
            margin: 0 0 6px;
            font-size: 20px;
            letter-spacing: .2px;
        }

        p {
            margin: 6px 0 0;
            color: var(--muted);
            line-height: 1.35
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            margin-top: 16px;
        }

        @media (max-width: 980px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, .04), rgba(255, 255, 255, .02));
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 14px;
            box-shadow: 0 16px 40px rgba(0, 0, 0, .35);
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: flex-end
        }

        label {
            font-size: 12px;
            color: var(--muted);
            display: block;
            margin: 10px 0 6px
        }

        input[type="file"],
        input[type="number"],
        input[type="text"],
        textarea,
        select {
            background: rgba(0, 0, 0, .25);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 10px;
            outline: none;
        }

        input[type="number"],
        input[type="text"],
        select {
            height: 40px;
        }

        textarea {
            width: 100%;
            min-height: 110px;
            resize: vertical
        }

        .btn {
            appearance: none;
            border: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(125, 211, 252, .20), rgba(125, 211, 252, .08));
            color: var(--text);
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 650;
        }

        .btn:disabled {
            opacity: .55;
            cursor: not-allowed
        }

        .btn.secondary {
            background: linear-gradient(180deg, rgba(167, 139, 250, .18), rgba(167, 139, 250, .07));
        }

        .btn.ghost {
            background: rgba(0, 0, 0, .18);
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        .previews {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        @media (max-width: 540px) {
            .previews {
                grid-template-columns: 1fr;
            }
        }

        canvas.preview {
            width: 100%;
            background: rgba(0, 0, 0, .28);
            border: 1px solid var(--border);
            border-radius: 14px;
            image-rendering: auto;
        }

        .kpi {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px
        }

        .pill {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 8px 10px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, .20);
            font-size: 12px;
            color: var(--muted);
        }

        .pill b {
            color: var(--text);
            font-size: 12px
        }

        .pill.good b {
            color: var(--good)
        }

        .pill.warn b {
            color: var(--warn)
        }

        .pill.bad b {
            color: var(--bad)
        }

        .results {
            margin-top: 10px;
            border-top: 1px dashed var(--border);
            padding-top: 10px;
        }

        .results ol {
            margin: 8px 0 0 18px;
            color: var(--muted)
        }

        .results li {
            margin: 4px 0
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
        }

        .sliderRow {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap
        }

        input[type="range"] {
            width: 220px
        }

        .warnBox {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(251, 191, 36, .35);
            background: rgba(251, 191, 36, .08);
            color: rgba(251, 191, 36, .95);
            font-size: 12px;
            line-height: 1.35;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>Image Transform Fingerprint Lab - Crop Test</h1>
        <p>
            Encode: upload <b>A</b>, enter tracking number <b>B</b> → get downloadable <b>C</b> with random rotation
            (±10°) and 4 random crop amounts (16-64px per side).<br />
            Decode: upload <b>A</b> + leaked/downloaded <b>C</b>, test candidate <b>B</b> values → correlation ranks
            likely leaker.
        </p>

        <div class="grid">
            <!-- ENCODE -->
            <div class="card">
                <h2 style="margin:0 0 8px;font-size:16px">1) Encoder (A + B → C)</h2>

                <div class="row">
                    <div style="flex:1;min-width:240px">
                        <label>Upload Image A (original)</label>
                        <input id="encA" type="file" accept="image/*" />
                    </div>
                    <div style="width:220px">
                        <label>Number B (tracking ID)</label>
                        <input id="encB" type="number" value="12345" min="0" step="1" />
                    </div>
                </div>

                <div class="row" style="margin-top:6px">
                    <div style="flex:1;min-width:280px">
                        <div class="sliderRow">
                            <button class="btn ghost" id="randB" type="button">Random B</button>
                        </div>
                    </div>
                    <div style="display:flex;gap:10px;align-items:end">
                        <button class="btn" id="btnEncode" type="button" disabled>Generate C</button>
                        <button class="btn secondary" id="btnDownload" type="button" disabled>Download C</button>
                    </div>
                </div>

                <div class="previews">
                    <div>
                        <label>Preview A</label>
                        <canvas id="canA" class="preview" width="640" height="360"></canvas>
                    </div>
                    <div>
                        <label>Preview C (encoded)</label>
                        <canvas id="canC" class="preview" width="640" height="360"></canvas>
                    </div>
                </div>

                <div class="kpi">
                    <span class="pill"><span class="small">A size</span> <b id="aSize">—</b></span>
                    <span class="pill"><span class="small">C size</span> <b id="cSize">—</b></span>
                    <span class="pill"><span class="small">rotation</span> <b id="rotationEcho">—</b></span>
                    <span class="pill"><span class="small">crop top</span> <b id="cropTop">—</b></span>
                    <span class="pill"><span class="small">crop right</span> <b id="cropRight">—</b></span>
                    <span class="pill"><span class="small">crop bottom</span> <b id="cropBottom">—</b></span>
                    <span class="pill"><span class="small">crop left</span> <b id="cropLeft">—</b></span>
                </div>

                <div class="warnBox">
                    This version tests rotation (±10°) + 4-sided independent cropping (16-64px per side).
                </div>
            </div>

            <!-- DECODE -->
            <div class="card">
                <h2 style="margin:0 0 8px;font-size:16px">2) Decoder (A + C → best B)</h2>

                <div class="row">
                    <div style="flex:1;min-width:240px">
                        <label>Upload Image A (original)</label>
                        <input id="decA" type="file" accept="image/*" />
                    </div>
                    <div style="flex:1;min-width:240px">
                        <label>Upload Image C (downloaded/leaked)</label>
                        <input id="decC" type="file" accept="image/*" />
                    </div>
                </div>

                <div class="row" style="margin-top:6px">
                    <div style="flex:1;min-width:280px">
                        <label>Candidate B values (comma / space / newline separated)</label>
                        <textarea id="candidates" class="mono" placeholder="Example:
12345
12346
20001,20002,20003"></textarea>
                    </div>
                </div>

                <div class="row" style="margin-top:6px">
                    <div style="flex:1;min-width:280px">
                        <label>Or brute force range (small ranges only)</label>
                        <div class="row">
                            <div>
                                <input id="bfStart" type="number" value="12340" step="1" />
                                <div class="small">start</div>
                            </div>
                            <div>
                                <input id="bfEnd" type="number" value="12360" step="1" />
                                <div class="small">end (inclusive)</div>
                            </div>
                            <div>
                                <input id="bfStep" type="number" value="1" step="1" min="1" />
                                <div class="small">step</div>
                            </div>
                            <button class="btn ghost" id="fillRange" type="button">Fill candidates from range</button>
                        </div>
                    </div>

                    <div style="flex:1;min-width:280px">
                        <label>Decoder options</label>
                        <div class="row">
                            <div>
                                <select id="downsample">
                                    <option value="64">Downsample 64×64 (fast)</option>
                                    <option value="96">Downsample 96×96</option>
                                    <option value="128" selected>Downsample 128×128 (best)</option>
                                </select>
                                <div class="small">correlation grid</div>
                            </div>
                            <div style="display:flex;gap:10px;align-items:end">
                                <button class="btn" id="btnDecode" type="button" disabled>Try candidates</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="previews">
                    <div>
                        <label>Decoder: A</label>
                        <canvas id="canDA" class="preview" width="640" height="360"></canvas>
                    </div>
                    <div>
                        <label>Decoder: best aligned C → A (using best B)</label>
                        <canvas id="canAligned" class="preview" width="640" height="360"></canvas>
                    </div>
                </div>

                <div class="kpi">
                    <span class="pill"><span class="small">best B</span> <b id="bestB">—</b></span>
                    <span class="pill good"><span class="small">best score</span> <b id="bestScore">—</b></span>
                    <span class="pill"><span class="small">tested</span> <b id="testedN">0</b></span>
                    <span class="pill"><span class="small">time</span> <b id="timeMs">—</b></span>
                </div>

                <div class="results">
                    <div class="small">Top matches (higher is more similar)</div>
                    <ol id="ranked"></ol>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* =========================================================
           Utilities: seeded PRNG, parsing, image load, sampling
           ========================================================= */

        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

        function mulberry32(seed) {
            let t = seed >>> 0;
            return function () {
                t += 0x6D2B79F5;
                let x = Math.imul(t ^ (t >>> 15), 1 | t);
                x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
                return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
            };
        }

        function seedFromInt(n) {
            // mix integer into 32-bit seed
            let x = (Number(n) >>> 0);
            x ^= x << 13; x >>>= 0;
            x ^= x >>> 17; x >>>= 0;
            x ^= x << 5; x >>>= 0;
            return x >>> 0;
        }

        function parseCandidates(text) {
            const parts = text
                .replace(/[#].*$/gm, '') // allow comments starting with #
                .split(/[\s,]+/g)
                .map(s => s.trim())
                .filter(Boolean);
            const nums = [];
            for (const p of parts) {
                const v = Number(p);
                if (Number.isFinite(v)) nums.push(Math.floor(v));
            }
            // de-dup preserving order
            const seen = new Set();
            const out = [];
            for (const v of nums) {
                const k = String(v);
                if (!seen.has(k)) { seen.add(k); out.push(v); }
            }
            return out;
        }

        async function fileToImage(file) {
            const url = URL.createObjectURL(file);
            try {
                const img = new Image();
                img.decoding = "async";
                img.src = url;
                await img.decode();
                return img;
            } finally {
                // Keep URL until decode done; release later if you want.
                // URL.revokeObjectURL(url);
            }
        }

        function fitCanvasToImage(canvas, img, maxW = 1200, maxH = 900) {
            const w = img.naturalWidth || img.width;
            const h = img.naturalHeight || img.height;
            const s = Math.min(maxW / w, maxH / h, 1);
            canvas.width = Math.max(1, Math.round(w * s));
            canvas.height = Math.max(1, Math.round(h * s));
            return { w: canvas.width, h: canvas.height, scale: s };
        }

        function drawImageToCanvas(canvas, img) {
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        function getImageData(canvas) {
            const ctx = canvas.getContext("2d");
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        function putImageData(canvas, imgData) {
            const ctx = canvas.getContext("2d");
            ctx.putImageData(imgData, 0, 0);
        }

        function sampleBilinear(src, x, y) {
            // src: ImageData, x,y in source pixel coords
            const w = src.width, h = src.height;
            if (x < 0 || y < 0 || x > w - 1 || y > h - 1) return [0, 0, 0, 0];

            const x0 = Math.floor(x), y0 = Math.floor(y);
            const x1 = Math.min(x0 + 1, w - 1), y1 = Math.min(y0 + 1, h - 1);
            const dx = x - x0, dy = y - y0;

            const idx = (xx, yy) => (yy * w + xx) * 4;
            const p00 = idx(x0, y0), p10 = idx(x1, y0), p01 = idx(x0, y1), p11 = idx(x1, y1);

            const d = src.data;
            const out = [0, 0, 0, 0];
            for (let c = 0; c < 4; c++) {
                const v00 = d[p00 + c], v10 = d[p10 + c], v01 = d[p01 + c], v11 = d[p11 + c];
                const v0 = v00 * (1 - dx) + v10 * dx;
                const v1 = v01 * (1 - dx) + v11 * dx;
                out[c] = v0 * (1 - dy) + v1 * dy;
            }
            return out;
        }

        function rgbToLuma(r, g, b) {
            // Rec.709-ish
            return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        }

        /* =========================================================
           Transform parameterization from B
           Random rotation ±10°, zoom (1.05-1.20x), shift, and 4 random crop amounts (16-64px per side)
           ========================================================= */

        function paramsFromB(B) {
            const seed = seedFromInt(B);
            const rnd = mulberry32(seed);

            // Random rotation: -10 to +10 degrees
            const angleDeg = (rnd() * 20) - 10; // range: -10 to +10
            const angle = angleDeg * Math.PI / 180;

            // Random zoom: 1.05 to 1.20x (zoom in)
            const zoom = 1.05 + rnd() * 0.15; // range: 1.05 to 1.20

            // Random shift: +/- pixels
            const maxShift = 30; // max shift in pixels
            const shiftX = (rnd() * 2 - 1) * maxShift; // range: -30 to +30
            const shiftY = (rnd() * 2 - 1) * maxShift; // range: -30 to +30

            // Random crop amounts for each side: 16 to 64 pixels
            const cropTop = 16 + Math.floor(rnd() * (64 - 16 + 1));
            const cropRight = 16 + Math.floor(rnd() * (64 - 16 + 1));
            const cropBottom = 16 + Math.floor(rnd() * (64 - 16 + 1));
            const cropLeft = 16 + Math.floor(rnd() * (64 - 16 + 1));

            return {
                B,
                angle,
                angleDeg,
                zoom,
                shiftX,
                shiftY,
                cropTop,
                cropRight,
                cropBottom,
                cropLeft
            };
        }

        /* =========================================================
           Warp / Transform core
           Steps: rotate → zoom in → shift → crop → rescale to original ratio
           ========================================================= */

        function warpImage(srcImgData, params, applyInverse = false) {
            const w = srcImgData.width, h = srcImgData.height;
            const cx = (w - 1) / 2, cy = (h - 1) / 2;

            // Step 1: Apply rotation + zoom + shift
            const temp = new ImageData(w, h);
            const ang = applyInverse ? -params.angle : params.angle;
            const ca = Math.cos(ang), sa = Math.sin(ang);
            const zoom = params.zoom || 1.0;
            const sx = applyInverse ? -params.shiftX : params.shiftX;
            const sy = applyInverse ? -params.shiftY : params.shiftY;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;

                    // Center coordinates
                    let px = x - cx;
                    let py = y - cy;

                    // Apply rotation (inverse mapping)
                    const rx = px * ca - py * sa;
                    const ry = px * sa + py * ca;

                    // Apply zoom (inverse = divide by zoom to sample from larger area)
                    const zx = applyInverse ? rx * zoom : rx / zoom;
                    const zy = applyInverse ? ry * zoom : ry / zoom;

                    // Apply shift
                    const finalX = zx - sx + cx;
                    const finalY = zy - sy + cy;

                    const p = sampleBilinear(srcImgData, finalX, finalY);
                    temp.data[idx + 0] = p[0];
                    temp.data[idx + 1] = p[1];
                    temp.data[idx + 2] = p[2];
                    temp.data[idx + 3] = 255;
                }
            }

            // Step 2: Crop from the transformed image
            const cropT = 0//params.cropTop || 0;
            const cropR = 0//params.cropRight || 0;
            const cropB = 0//params.cropBottom || 0;
            const cropL = 0//params.cropLeft || 0;

            const croppedW = w - cropL - cropR;
            const croppedH = h - cropT - cropB;

            const cropped = new ImageData(croppedW, croppedH);
            for (let y = 0; y < croppedH; y++) {
                for (let x = 0; x < croppedW; x++) {
                    const srcX = x + cropL;
                    const srcY = y + cropT;
                    const srcIdx = (srcY * w + srcX) * 4;
                    const dstIdx = (y * croppedW + x) * 4;

                    cropped.data[dstIdx + 0] = temp.data[srcIdx + 0];
                    cropped.data[dstIdx + 1] = temp.data[srcIdx + 1];
                    cropped.data[dstIdx + 2] = temp.data[srcIdx + 2];
                    cropped.data[dstIdx + 3] = 255;
                }
            }

            // Step 3: Rescale back to original dimensions
            const out = new ImageData(w, h);
            const scaleX = croppedW / w;
            const scaleY = croppedH / h;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    
                    // Sample from cropped image
                    const srcX = x * scaleX;
                    const srcY = y * scaleY;
                    const p = sampleBilinear(cropped, srcX, srcY);

                    out.data[idx + 0] = p[0];
                    out.data[idx + 1] = p[1];
                    out.data[idx + 2] = p[2];
                    out.data[idx + 3] = 255;
                }
            }

            return out;
        }

        /* =========================================================
           Similarity (Normalized Cross-Correlation on grayscale)
           ========================================================= */

        function downsampleToGray(imgData, N) {
            // returns Float32Array length N*N, values zero-mean not applied yet
            const w = imgData.width, h = imgData.height;
            const out = new Float32Array(N * N);
            const sx = w / N, sy = h / N;
            const d = imgData.data;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    // sample at cell center
                    const x = (i + 0.5) * sx;
                    const y = (j + 0.5) * sy;
                    const p = sampleBilinear(imgData, x, y);
                    out[j * N + i] = rgbToLuma(p[0], p[1], p[2]) / 255;
                }
            }
            return out;
        }

        function ncc(a, b) {
            // normalized cross correlation of two Float32 arrays
            const n = a.length;
            let meanA = 0, meanB = 0;
            for (let i = 0; i < n; i++) { meanA += a[i]; meanB += b[i]; }
            meanA /= n; meanB /= n;

            let num = 0, denA = 0, denB = 0;
            for (let i = 0; i < n; i++) {
                const da = a[i] - meanA;
                const db = b[i] - meanB;
                num += da * db;
                denA += da * da;
                denB += db * db;
            }
            const den = Math.sqrt(denA * denB) + 1e-12;
            return num / den;
        }

        /* =========================================================
           App state + UI wiring
           ========================================================= */

        const enc = {
            imgA: null,
            imgDataA: null,
            imgDataC: null,
            lastParams: null,
        };

        const dec = {
            imgA: null,
            imgC: null,
            imgDataA: null,
            imgDataC: null,
        };

        const $ = (id) => document.getElementById(id);

        const canA = $("canA");
        const canC = $("canC");
        const canDA = $("canDA");
        const canAligned = $("canAligned");

        $("randB").addEventListener("click", () => {
            const r = Math.floor(Math.random() * 1e9);
            $("encB").value = r;
        });

        $("encA").addEventListener("change", async (e) => {
            const f = e.target.files?.[0];
            if (!f) return;
            enc.imgA = await fileToImage(f);
            fitCanvasToImage(canA, enc.imgA, 1200, 900);
            fitCanvasToImage(canC, enc.imgA, 1200, 900);
            drawImageToCanvas(canA, enc.imgA);
            enc.imgDataA = getImageData(canA);

            $("aSize").textContent = `${enc.imgDataA.width}×${enc.imgDataA.height}`;
            $("btnEncode").disabled = false;
        });

        $("btnEncode").addEventListener("click", () => {
            if (!enc.imgDataA) return;
            const B = Number($("encB").value || 0);

            const params = paramsFromB(B);
            enc.lastParams = params;
            const out = warpImage(enc.imgDataA, params, false);
            enc.imgDataC = out;

            putImageData(canC, out);
            $("cSize").textContent = `${out.width}×${out.height}`;
            $("rotationEcho").textContent = `${params.angleDeg.toFixed(2)}° | zoom: ${params.zoom.toFixed(3)}x | shift: (${params.shiftX.toFixed(1)}, ${params.shiftY.toFixed(1)})`;
            $("cropTop").textContent = `${params.cropTop}px`;
            $("cropRight").textContent = `${params.cropRight}px`;
            $("cropBottom").textContent = `${params.cropBottom}px`;
            $("cropLeft").textContent = `${params.cropLeft}px`;
            $("btnDownload").disabled = false;
        });

        $("btnDownload").addEventListener("click", () => {
            if (!enc.imgDataC) return;
            const a = document.createElement("a");
            const B = $("encB").value;
            a.download = `C_crop_B${B}.png`;
            a.href = canC.toDataURL("image/png");
            a.click();
        });

        $("fillRange").addEventListener("click", () => {
            const s = Math.floor(Number($("bfStart").value || 0));
            const e = Math.floor(Number($("bfEnd").value || 0));
            const step = Math.max(1, Math.floor(Number($("bfStep").value || 1)));
            const lo = Math.min(s, e), hi = Math.max(s, e);

            const vals = [];
            for (let v = lo; v <= hi; v += step) vals.push(v);
            $("candidates").value = vals.join("\n");
        });

        $("decA").addEventListener("change", async (e) => {
            const f = e.target.files?.[0];
            if (!f) return;
            dec.imgA = await fileToImage(f);
            fitCanvasToImage(canDA, dec.imgA, 1200, 900);
            drawImageToCanvas(canDA, dec.imgA);
            dec.imgDataA = getImageData(canDA);
            updateDecodeReady();
        });

        $("decC").addEventListener("change", async (e) => {
            const f = e.target.files?.[0];
            if (!f) return;
            dec.imgC = await fileToImage(f);

            // Make aligned canvas match A canvas size for consistent compare
            if (dec.imgDataA) {
                canAligned.width = canDA.width;
                canAligned.height = canDA.height;
            } else {
                fitCanvasToImage(canAligned, dec.imgC, 1200, 900);
            }
            const ctx = canAligned.getContext("2d");
            ctx.clearRect(0, 0, canAligned.width, canAligned.height);
            ctx.drawImage(dec.imgC, 0, 0, canAligned.width, canAligned.height);

            dec.imgDataC = getImageData(canAligned);
            updateDecodeReady();
        });

        function updateDecodeReady() {
            $("btnDecode").disabled = !(dec.imgDataA && dec.imgDataC);
        }

        $("btnDecode").addEventListener("click", async () => {
            if (!(dec.imgDataA && dec.imgDataC)) return;

            const N = Number($("downsample").value || 128);

            const candidates = parseCandidates($("candidates").value);
            if (candidates.length === 0) {
                alert("Provide some candidate B values (or use 'Fill candidates from range').");
                return;
            }

            $("testedN").textContent = "0";
            $("bestB").textContent = "—";
            $("bestScore").textContent = "—";
            $("timeMs").textContent = "—";
            $("ranked").innerHTML = "";

            const t0 = performance.now();

            // Precompute A downsample
            const Agray = downsampleToGray(dec.imgDataA, N);

            // We'll test each candidate by "undoing" transform on C and correlating with A
            const scores = [];

            for (let i = 0; i < candidates.length; i++) {
                const B = candidates[i];
                const params = paramsFromB(B);

                // Align: apply inverse transform to C (so it should resemble A)
                const aligned = warpImage(dec.imgDataC, params, true);
                const Cgray = downsampleToGray(aligned, N);
                const score = ncc(Agray, Cgray);

                scores.push({ B, score, aligned });
                $("testedN").textContent = String(i + 1);

                // Yield to UI occasionally
                if ((i % 15) === 14) await new Promise(r => setTimeout(r, 0));
            }

            scores.sort((a, b) => b.score - a.score);
            const best = scores[0];

            const t1 = performance.now();
            $("bestB").textContent = String(best.B);
            $("bestScore").textContent = best.score.toFixed(6);
            $("timeMs").textContent = `${Math.round(t1 - t0)} ms`;

            // Show best aligned
            putImageData(canAligned, best.aligned);

            // Show top 10
            const topK = Math.min(10, scores.length);
            const ol = $("ranked");
            for (let i = 0; i < topK; i++) {
                const it = scores[i];
                const li = document.createElement("li");
                li.innerHTML = `<span class="mono">B=${it.B}</span> — score <span class="mono">${it.score.toFixed(6)}</span>`;
                ol.appendChild(li);
            }
        });

    </script>
</body>

</html>