<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Seeded Tileable Noise (Reversible)</title>
  <style>
    :root{
      --bg:#0b1220; --card:#0f1b33; --muted:#9fb0cc; --text:#eaf1ff;
      --accent:#66e3ff; --border:#1f335a; --good:#64ffb8; --warn:#ffcc66;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background: radial-gradient(1200px 600px at 20% 0%, #12224a 0%, var(--bg) 60%);
      color:var(--text);
    }
    .wrap{max-width:1200px; margin:0 auto; padding:20px}
    h1{margin:6px 0 16px; font-size:22px}
    h2{margin:0 0 10px; font-size:16px; color:#d9e6ff}
    .grid{display:grid; grid-template-columns:1fr; gap:14px}
    @media (min-width: 980px){ .grid{grid-template-columns:1fr 1fr} }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .row > *{flex:0 0 auto}
    label{font-size:12px; color:var(--muted)}
    input[type="file"]{max-width:100%}
    input[type="number"], input[type="text"], textarea{
      background:#0b1733;
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:9px 10px;
      outline:none;
    }
    textarea{width:100%; min-height:92px; resize:vertical; line-height:1.3}
    .btn{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(102,227,255,.18), rgba(102,227,255,.08));
      color:var(--text);
      border-radius:12px;
      padding:9px 12px;
      cursor:pointer;
      transition: transform .05s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px)}
    .btn.secondary{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
    }
    .btn.ghost{
      background: transparent;
    }
    .pill{
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:var(--muted);
      background: rgba(0,0,0,.15);
    }
    .sliderWrap{display:flex; align-items:center; gap:8px}
    input[type="range"]{width:240px}
    .kv{
      display:grid; grid-template-columns: 140px 1fr;
      gap:8px 10px;
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
    }
    .kv div:nth-child(2n){color:var(--text)}
    .canvRow{display:grid; gap:10px; grid-template-columns:1fr}
    @media (min-width: 980px){ .canvRow{grid-template-columns: 1fr 1fr} }
    canvas{
      width:100%;
      background:#081027;
      border:1px solid var(--border);
      border-radius:14px;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:6px}
    .status{font-size:12px; color:var(--muted); margin-top:8px}
    .status b{color:var(--good)}
    .warn b{color:var(--warn)}
    code.inline{
      background: rgba(0,0,0,.25);
      border:1px solid var(--border);
      padding:2px 6px;
      border-radius:8px;
      font-size:12px;
      color:#d8e6ff;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Seeded Tileable Noise (Reversible Add/Sub Mod 256)</h1>

    <div class="grid">

      <!-- =========================
           Forward / Add Noise
      ========================== -->
      <section class="card">
        <h2>1) Add noise (forward)</h2>

        <div class="row">
          <div>
            <label>Upload image</label><br />
            <input id="inOriginal" type="file" accept="image/*" />
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <div>
            <label>Seed (32-bit integer)</label><br />
            <div class="row">
              <input id="seed" type="number" step="1" value="123456789" style="width:220px" />
              <button id="btnRandomSeed" class="btn secondary">Random seed</button>
            </div>
          </div>

          <div>
            <label>Noise intensity (max abs per channel)</label><br />
            <div class="sliderWrap">
              <button id="btnIntMinus" class="btn ghost">−</button>
              <input id="intensity" type="range" min="0" max="127" value="24" />
              <button id="btnIntPlus" class="btn ghost">+</button>
              <input id="intensityNum" type="number" min="0" max="127" value="24" style="width:80px" />
            </div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <button id="btnAddNoise" class="btn">Generate + Apply noise</button>
          <button id="btnDownloadNoisy" class="btn secondary" disabled>Download noisy PNG</button>
          <span class="pill" id="tileInfo">Tile: —</span>
        </div>

        <div class="kv" id="paramsKv" style="display:none">
          <!-- filled by JS -->
        </div>

        <div class="row" style="margin-top:10px">
          <button id="btnCopyParams" class="btn secondary" disabled>Copy parameters</button>
          <input id="paramsText" type="text" readonly style="flex:1 1 420px; min-width:280px" />
        </div>
        <div class="hint">
          Parameters include the image dimensions, computed tile size, seed, intensity, and algorithm version.
          Keep them with the noisy image to reverse it later.
        </div>

        <div style="height:10px"></div>

        <div class="canvRow">
          <div>
            <label>Original</label>
            <canvas id="cvOriginal"></canvas>
          </div>
          <div>
            <label>Noisy output</label>
            <canvas id="cvNoisy"></canvas>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="canvRow">
          <div>
            <label>Noise tile preview (visualized as 128 + offset)</label>
            <canvas id="cvNoiseTile"></canvas>
          </div>
          <div>
            <label>Noise tile (zoomed)</label>
            <canvas id="cvNoiseTileZoom"></canvas>
          </div>
        </div>

        <div class="status" id="statusForward">Status: —</div>
      </section>

      <!-- =========================
           Reverse / Restore
      ========================== -->
      <section class="card">
        <h2>2) Reverse noise (restore)</h2>

        <div class="row">
          <div>
            <label>Upload noisy image</label><br />
            <input id="inNoisy" type="file" accept="image/*" />
          </div>
        </div>

        <div style="height:10px"></div>

        <label>Paste parameters (copied from above)</label>
        <textarea id="paramsPaste" placeholder='{"v":1,"w":512,"h":384,"tile":128,"seed":123,"intensity":24,"mode":"add_mod256_tile","prng":"mulberry32","note":"..."}'></textarea>

        <div class="row" style="margin-top:10px">
          <button id="btnRestore" class="btn">Restore (reverse noise)</button>
          <button id="btnDownloadRestored" class="btn secondary" disabled>Download restored PNG</button>
          <span class="pill" id="restoreInfo">—</span>
        </div>

        <div class="hint">
          Restore is done by regenerating the same tileable noise from the parameters, then
          applying modulo subtraction (i.e., reverse of the forward pass).
        </div>

        <div style="height:10px"></div>

        <div class="canvRow">
          <div>
            <label>Noisy input</label>
            <canvas id="cvNoisyIn"></canvas>
          </div>
          <div>
            <label>Restored output</label>
            <canvas id="cvRestored"></canvas>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="canvRow">
          <div>
            <label>Regenerated noise tile preview</label>
            <canvas id="cvNoiseTile2"></canvas>
          </div>
          <div>
            <label>Regenerated noise tile (zoomed)</label>
            <canvas id="cvNoiseTileZoom2"></canvas>
          </div>
        </div>

        <div class="status" id="statusRestore">Status: —</div>
      </section>

    </div>

    <div class="hint" style="margin-top:14px">
      Implementation notes:
      <span class="inline code inline">noisy = (orig + offset) mod 256</span>,
      <span class="inline code inline">restored = (noisy - offset) mod 256</span>.
      Noise is tileable using <span class="inline code inline">tile = gcd(width,height)</span> (square tile).
    </div>
  </div>

<script>
/* =========================
   Utilities
========================= */
function gcd(a, b) {
  a = Math.abs(a|0); b = Math.abs(b|0);
  while (b !== 0) { const t = a % b; a = b; b = t; }
  return a;
}

function mod(n, m) {
  // true mathematical modulo for negatives
  return ((n % m) + m) % m;
}

// Mulberry32 PRNG (seeded, fast, deterministic)
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let x = Math.imul(t ^ (t >>> 15), 1 | t);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296; // [0,1)
  };
}

async function fileToImage(file) {
  const url = URL.createObjectURL(file);
  try {
    const img = new Image();
    img.decoding = "async";
    img.src = url;
    await img.decode();
    return img;
  } finally {
    // keep url alive until img is decoded; revoke after decode
    // (done in finally because decode awaited above)
    // revoke *after* decode by scheduling microtask
    setTimeout(() => URL.revokeObjectURL(url), 0);
  }
}

function fitCanvasToImage(cv, w, h) {
  cv.width = w;
  cv.height = h;
}

function drawImageToCanvas(img, cv) {
  fitCanvasToImage(cv, img.naturalWidth, img.naturalHeight);
  const ctx = cv.getContext("2d", { willReadFrequently: true });
  ctx.clearRect(0, 0, cv.width, cv.height);
  ctx.drawImage(img, 0, 0);
  return ctx;
}

function canvasToPngBlob(cv) {
  return new Promise(resolve => cv.toBlob(resolve, "image/png"));
}

function downloadBlob(blob, filename) {
  const a = document.createElement("a");
  const url = URL.createObjectURL(blob);
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 0);
}

function clampInt(n, lo, hi) {
  n = Number(n);
  if (!Number.isFinite(n)) n = lo;
  return Math.max(lo, Math.min(hi, Math.round(n)));
}

/* =========================
   Noise generation (tileable)
   - offsets are integers in [-intensity, +intensity]
   - tile is square: tile x tile
========================= */
function generateNoiseTileOffsets(tileSize, seed, intensity) {
  const rand = mulberry32(seed >>> 0);
  const pxCount = tileSize * tileSize;

  // store offsets per pixel per channel (RGB), Int16 is plenty
  const offsets = new Int16Array(pxCount * 3);

  for (let p = 0; p < pxCount; p++) {
    const base = p * 3;
    // Uniform integer in [-intensity, +intensity]
    offsets[base + 0] = Math.round((rand() * 2 - 1) * intensity);
    offsets[base + 1] = Math.round((rand() * 2 - 1) * intensity);
    offsets[base + 2] = Math.round((rand() * 2 - 1) * intensity);
  }
  return offsets;
}

function applyNoiseAddMod256(imageData, tileOffsets, tileSize, intensity) {
  // intensity is not used here directly (offsets already scaled), included for clarity
  const w = imageData.width, h = imageData.height;
  const src = imageData.data;
  const out = new Uint8ClampedArray(src); // copy

  for (let y = 0; y < h; y++) {
    const ty = y % tileSize;
    for (let x = 0; x < w; x++) {
      const tx = x % tileSize;
      const tileIndex = (ty * tileSize + tx) * 3;
      const i = (y * w + x) * 4;

      out[i + 0] = mod(src[i + 0] + tileOffsets[tileIndex + 0], 256);
      out[i + 1] = mod(src[i + 1] + tileOffsets[tileIndex + 1], 256);
      out[i + 2] = mod(src[i + 2] + tileOffsets[tileIndex + 2], 256);
      // alpha unchanged
    }
  }
  return new ImageData(out, w, h);
}

function applyNoiseSubMod256(imageData, tileOffsets, tileSize) {
  const w = imageData.width, h = imageData.height;
  const src = imageData.data;
  const out = new Uint8ClampedArray(src); // copy

  for (let y = 0; y < h; y++) {
    const ty = y % tileSize;
    for (let x = 0; x < w; x++) {
      const tx = x % tileSize;
      const tileIndex = (ty * tileSize + tx) * 3;
      const i = (y * w + x) * 4;

      out[i + 0] = mod(src[i + 0] - tileOffsets[tileIndex + 0], 256);
      out[i + 1] = mod(src[i + 1] - tileOffsets[tileIndex + 1], 256);
      out[i + 2] = mod(src[i + 2] - tileOffsets[tileIndex + 2], 256);
    }
  }
  return new ImageData(out, w, h);
}

// Visualize offsets as RGB around 128 (so 0 offset = mid-gray)
function renderNoiseTilePreview(tileOffsets, tileSize, cv, zoom = 1) {
  const w = tileSize, h = tileSize;
  cv.width = w * zoom;
  cv.height = h * zoom;

  const tmp = document.createElement("canvas");
  tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext("2d", { willReadFrequently: true });
  const img = tctx.createImageData(w, h);

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const p = (y * w + x);
      const base3 = p * 3;
      const i = p * 4;

      const r = 128 + tileOffsets[base3 + 0];
      const g = 128 + tileOffsets[base3 + 1];
      const b = 128 + tileOffsets[base3 + 2];

      img.data[i + 0] = clampInt(r, 0, 255);
      img.data[i + 1] = clampInt(g, 0, 255);
      img.data[i + 2] = clampInt(b, 0, 255);
      img.data[i + 3] = 255;
    }
  }
  tctx.putImageData(img, 0, 0);

  const ctx = cv.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0, 0, cv.width, cv.height);
  ctx.drawImage(tmp, 0, 0, cv.width, cv.height);
}

/* =========================
   DOM wiring
========================= */
const el = (id) => document.getElementById(id);

const inOriginal = el("inOriginal");
const inNoisy = el("inNoisy");

const seedInput = el("seed");
const btnRandomSeed = el("btnRandomSeed");

const intensityRange = el("intensity");
const intensityNum = el("intensityNum");
const btnIntMinus = el("btnIntMinus");
const btnIntPlus = el("btnIntPlus");

const btnAddNoise = el("btnAddNoise");
const btnCopyParams = el("btnCopyParams");
const paramsText = el("paramsText");
const paramsKv = el("paramsKv");
const tileInfo = el("tileInfo");
const statusForward = el("statusForward");
const btnDownloadNoisy = el("btnDownloadNoisy");

const cvOriginal = el("cvOriginal");
const cvNoisy = el("cvNoisy");
const cvNoiseTile = el("cvNoiseTile");
const cvNoiseTileZoom = el("cvNoiseTileZoom");

const paramsPaste = el("paramsPaste");
const btnRestore = el("btnRestore");
const restoreInfo = el("restoreInfo");
const statusRestore = el("statusRestore");
const btnDownloadRestored = el("btnDownloadRestored");

const cvNoisyIn = el("cvNoisyIn");
const cvRestored = el("cvRestored");
const cvNoiseTile2 = el("cvNoiseTile2");
const cvNoiseTileZoom2 = el("cvNoiseTileZoom2");

let forwardState = {
  origImageData: null,
  noisyImageData: null,
  params: null,
};

let restoreState = {
  noisyImageData: null,
  restoredImageData: null,
  params: null,
};

function syncIntensity(from) {
  if (from === "range") {
    intensityNum.value = intensityRange.value;
  } else if (from === "num") {
    intensityRange.value = clampInt(intensityNum.value, 0, 127);
    intensityNum.value = intensityRange.value;
  }
}
intensityRange.addEventListener("input", () => syncIntensity("range"));
intensityNum.addEventListener("input", () => syncIntensity("num"));

btnIntMinus.addEventListener("click", () => {
  intensityRange.value = clampInt(Number(intensityRange.value) - 1, 0, 127);
  syncIntensity("range");
});
btnIntPlus.addEventListener("click", () => {
  intensityRange.value = clampInt(Number(intensityRange.value) + 1, 0, 127);
  syncIntensity("range");
});

btnRandomSeed.addEventListener("click", () => {
  const u = new Uint32Array(1);
  crypto.getRandomValues(u);
  seedInput.value = (u[0] >>> 0);
});

inOriginal.addEventListener("change", async () => {
  forwardState.origImageData = null;
  forwardState.noisyImageData = null;
  forwardState.params = null;
  paramsText.value = "";
  paramsKv.style.display = "none";
  btnCopyParams.disabled = true;
  btnDownloadNoisy.disabled = true;

  const file = inOriginal.files?.[0];
  if (!file) return;

  const img = await fileToImage(file);
  const ctx = drawImageToCanvas(img, cvOriginal);
  const imgData = ctx.getImageData(0, 0, cvOriginal.width, cvOriginal.height);
  forwardState.origImageData = imgData;

  // Clear outputs
  fitCanvasToImage(cvNoisy, imgData.width, imgData.height);
  cvNoisy.getContext("2d").clearRect(0,0,cvNoisy.width, cvNoisy.height);

  tileInfo.textContent = `Tile: gcd(${imgData.width}, ${imgData.height}) = ${gcd(imgData.width, imgData.height)} (square)`;
  statusForward.textContent = `Status: Loaded original (${imgData.width}×${imgData.height}).`;
});

inNoisy.addEventListener("change", async () => {
  restoreState.noisyImageData = null;
  restoreState.restoredImageData = null;
  restoreState.params = null;
  btnDownloadRestored.disabled = true;

  const file = inNoisy.files?.[0];
  if (!file) return;

  const img = await fileToImage(file);
  const ctx = drawImageToCanvas(img, cvNoisyIn);
  restoreState.noisyImageData = ctx.getImageData(0, 0, cvNoisyIn.width, cvNoisyIn.height);

  fitCanvasToImage(cvRestored, restoreState.noisyImageData.width, restoreState.noisyImageData.height);
  cvRestored.getContext("2d").clearRect(0,0,cvRestored.width, cvRestored.height);

  statusRestore.textContent = `Status: Loaded noisy (${restoreState.noisyImageData.width}×${restoreState.noisyImageData.height}). Paste params and click Restore.`;
});

btnAddNoise.addEventListener("click", () => {
  try {
    const original = forwardState.origImageData;
    if (!original) {
      statusForward.textContent = "Status: Please upload an original image first.";
      return;
    }

    const w = original.width, h = original.height;
    const seed = (Number(seedInput.value) >>> 0);
    const intensity = clampInt(intensityRange.value, 0, 127);

    // tileable: choose square tile = gcd(w,h)
    const tile = gcd(w, h);
    if (tile <= 0) throw new Error("Invalid tile size computed.");

    // Generate tile offsets (small, repeated)
    const tileOffsets = generateNoiseTileOffsets(tile, seed, intensity);

    // Apply
    const noisy = applyNoiseAddMod256(original, tileOffsets, tile, intensity);

    // Draw noisy
    fitCanvasToImage(cvNoisy, w, h);
    cvNoisy.getContext("2d").putImageData(noisy, 0, 0);

    // Render noise tile previews
    renderNoiseTilePreview(tileOffsets, tile, cvNoiseTile, 1);
    const zoom = Math.max(2, Math.floor(256 / Math.max(tile, 1))); // adaptive
    renderNoiseTilePreview(tileOffsets, tile, cvNoiseTileZoom, zoom);

    // Store params (sufficient to regenerate tile offsets exactly)
    const params = {
      v: 1,
      mode: "add_mod256_tile",
      prng: "mulberry32",
      w, h,
      tile,
      seed,
      intensity,
      note: "Keep these params with the noisy image to reverse it."
    };

    forwardState.noisyImageData = noisy;
    forwardState.params = params;

    // Show params + copy
    const paramsStr = JSON.stringify(params);
    paramsText.value = paramsStr;
    btnCopyParams.disabled = false;
    btnDownloadNoisy.disabled = false;

    // Show key-values
    paramsKv.innerHTML = `
      <div>Version</div><div>${params.v}</div>
      <div>Mode</div><div>${params.mode}</div>
      <div>PRNG</div><div>${params.prng}</div>
      <div>Image</div><div>${params.w}×${params.h}</div>
      <div>Tile</div><div>${params.tile}×${params.tile} (square)</div>
      <div>Seed</div><div>${params.seed}</div>
      <div>Intensity</div><div>${params.intensity}</div>
    `;
    paramsKv.style.display = "grid";

    tileInfo.textContent = `Tile: ${tile}×${tile} (gcd of ${w}×${h})`;
    statusForward.innerHTML = `Status: <b>Applied noise</b> (seed=${seed}, intensity=${intensity}, tile=${tile}).`;
  } catch (e) {
    statusForward.textContent = `Status: Error: ${e?.message || e}`;
  }
});

btnCopyParams.addEventListener("click", async () => {
  try {
    if (!paramsText.value) return;
    await navigator.clipboard.writeText(paramsText.value);
    statusForward.innerHTML = `Status: <b>Copied</b> parameters to clipboard.`;
  } catch (e) {
    statusForward.textContent = `Status: Could not copy (browser permission). You can still manually copy the text.`;
  }
});

btnDownloadNoisy.addEventListener("click", async () => {
  if (!forwardState.noisyImageData) return;
  const blob = await canvasToPngBlob(cvNoisy);
  downloadBlob(blob, "noisy.png");
});

btnRestore.addEventListener("click", () => {
  try {
    const noisy = restoreState.noisyImageData;
    if (!noisy) {
      statusRestore.textContent = "Status: Please upload a noisy image first.";
      return;
    }
    const raw = paramsPaste.value.trim();
    if (!raw) {
      statusRestore.textContent = "Status: Please paste the parameters JSON.";
      return;
    }

    let params;
    try {
      params = JSON.parse(raw);
    } catch {
      statusRestore.textContent = "Status: Parameters are not valid JSON.";
      return;
    }

    // Basic validation / fallback
    const w = noisy.width, h = noisy.height;

    const seed = (Number(params.seed) >>> 0);
    const intensity = clampInt(params.intensity, 0, 127);

    let tile = clampInt(params.tile, 1, 1_000_000);
    const g = gcd(w, h);
    if (w !== params.w || h !== params.h) {
      // dimensions differ from recorded params; warn and try best-effort
      statusRestore.classList.add("warn");
    } else {
      statusRestore.classList.remove("warn");
    }

    // Ensure tile divides both dims; otherwise, fall back to gcd
    if ((w % tile) !== 0 || (h % tile) !== 0) {
      tile = g;
    }

    // Regenerate tile offsets deterministically
    const tileOffsets = generateNoiseTileOffsets(tile, seed, intensity);

    // Reverse
    const restored = applyNoiseSubMod256(noisy, tileOffsets, tile);

    // Draw restored
    fitCanvasToImage(cvRestored, w, h);
    cvRestored.getContext("2d").putImageData(restored, 0, 0);

    // Show regenerated noise tile previews
    renderNoiseTilePreview(tileOffsets, tile, cvNoiseTile2, 1);
    const zoom = Math.max(2, Math.floor(256 / Math.max(tile, 1)));
    renderNoiseTilePreview(tileOffsets, tile, cvNoiseTileZoom2, zoom);

    restoreState.params = { ...params, w, h, tile, seed, intensity };
    restoreState.restoredImageData = restored;

    btnDownloadRestored.disabled = false;
    restoreInfo.textContent = `Restore: seed=${seed}, intensity=${intensity}, tile=${tile}`;
    statusRestore.innerHTML = `Status: <b>Restored</b> via modulo subtraction. ${((w!==params.w)||(h!==params.h)) ? "(Warning: image dims differ from params; used best-effort.)" : ""}`;
  } catch (e) {
    statusRestore.textContent = `Status: Error: ${e?.message || e}`;
  }
});

btnDownloadRestored.addEventListener("click", async () => {
  if (!restoreState.restoredImageData) return;
  const blob = await canvasToPngBlob(cvRestored);
  downloadBlob(blob, "restored.png");
});
</script>
</body>
</html>
