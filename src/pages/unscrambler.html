<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Playback Scrambler / Unscrambler</title>
  <!-- CSS Variables and Main Styling -->
  <style>
    /* CSS Variables for consistent theming */
    :root {
      --gap: 12px;
      --bg: #0f172a;
      --card: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22d3ee;
      --border: #1f2937
    }

    /* Basic page layout and styling */
    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      background: linear-gradient(180deg, #0b1220, #0f172a);
      color: var(--text)
    }

    /* Typography */
    h1,
    h2 {
      margin: .2rem 0 0.6rem
    }

    h1 {
      font-size: 1.6rem
    }

    h2 {
      font-size: 1.2rem;
      color: #cbd5e1
    }

    /* Layout utilities */
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px
    }

    .grid {
      display: grid;
      gap: var(--gap)
    }

    .cols {
      grid-template-columns: repeat(12, 1fr)
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px
    }

    .row {
      display: flex;
      gap: var(--gap);
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 8px
    }

    .row:last-child {
      margin-bottom: 0
    }

    /* Form elements */
    label {
      display: block;
      font-size: .85rem;
      color: var(--muted);
      margin-bottom: 4px;
      margin-top: 8px
    }

    label:first-child {
      margin-top: 0
    }

    input,
    textarea,
    select,
    button {
      background: #0b1020;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      outline: none;
      box-sizing: border-box
    }

    input[type=number] {
      width: 110px;
      margin-right: 8px
    }

    textarea {
      width: 100%;
      min-height: 110px;
      resize: vertical;
      margin-bottom: 12px
    }

    /* Form containers */
    .form-group {
      margin-bottom: 16px
    }

    .form-group:last-child {
      margin-bottom: 0
    }

    /* Button styles */
    .btn {
      cursor: pointer;
      border: 1px solid #1f2b45;
      margin: 4px 6px 4px 0;
      white-space: nowrap
    }

    .btn:hover {
      border-color: #334155
    }

    .btn-accent {
      background: linear-gradient(90deg, #06b6d4, #22d3ee);
      color: #001018;
      border: none;
      margin: 4px 6px 4px 0
    }

    .icon-btn {
      padding: 8px 10px;
      line-height: 1;
      border-radius: 10px;
      border: 1px solid #1f2b45;
      background: #0b1020;
      margin-left: 8px
    }

    /* UI elements */
    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      background: #0b1220;
      border: 1px solid #1e293b;
      color: #93c5fd;
      font-size: .78rem;
      margin: 2px 4px
    }

    .hint {
      font-size: .85rem;
      color: var(--muted);
      margin: 4px 0 8px 0
    }

    /* Media display layout */
    .media-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 16px 0
    }

    video,
    canvas {
      width: 100%;
      height: auto;
      background: #0b1020;
      border: 1px dashed #1f2937;
      border-radius: 10px;
      margin-bottom: 8px
    }

    /* Status displays */
    .kpi {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 8px
    }

    .kpi .pill {
      margin: 2px
    }

    .kpi .pill b {
      color: #e2e8f0
    }

    .sep {
      height: 1px;
      background: #1f2937;
      margin: 16px 0
    }

    .small {
      font-size: .8rem
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
    }

    /* Header improvements */
    header {
      margin-bottom: 20px
    }

    header .row {
      align-items: flex-start;
      margin-bottom: 0
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .wrap {
        padding: 16px
      }

      .card {
        padding: 16px
      }

      .media-row {
        grid-template-columns: 1fr;
        gap: 16px
      }

      header .row {
        flex-direction: column;
        gap: 16px
      }

      .kpi {
        justify-content: flex-start
      }
    }

    /* Ad Modal Styles */
    .ad-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }

    .ad-modal.show {
      display: flex;
    }

    .ad-modal-content {
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
    }

    /* Mobile layout (aspect ratio < 10:16) */
    .ad-modal-content.mobile {
      width: 350px;
      height: 600px;
    }

    /* Desktop layout (aspect ratio > 4:3) */
    .ad-modal-content.desktop {
      width: 640px;
      height: 480px;
    }

    .ad-video {
      width: 100%;
      height: 70%;
      border-radius: 12px;
      background: #000;
    }

    .ad-content {
      height: 30%;
      padding: 16px 0 0 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .ad-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }

    .ad-description {
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 16px;
      line-height: 1.4;
    }

    .ad-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .ad-timer {
      font-size: 0.85rem;
      color: var(--accent);
      margin-right: auto;
    }

    .ad-close-btn {
      background: var(--accent);
      color: #001018;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      opacity: 0.5;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .ad-close-btn.enabled {
      opacity: 1;
      pointer-events: auto;
    }

    .ad-close-btn:hover.enabled {
      background: #06b6d4;
    }
  </style>
</head>

<body>
  <!-- Main container with responsive grid layout -->
  <div class="wrap grid" style="gap:18px">
    <!-- Header section with title and application info -->
    <header class="row" style="justify-content:space-between">
      <div>
        <h1>üéûÔ∏è Video Unscrambler</h1>
        <div class="hint">Upload a short video (‚â§ 60s), scramble it via tile-shifting, save the unscrambling algorithm
          key, and export the video result. Then later share the key to unscramble and restore the video.</div>
        <!-- restore with the saved JSON or Base64.</div> -->
      </div>
      <!-- Application status indicators -->
      <div class="kpi">
        <span class="pill">Canvas export: <b>WebM</b></span>
        <span class="pill">Grid range: <b>9 - 100 cells</b></span>
        <span class="pill">Display: <b>50-100% resolution</b></span>
      </div>
    </header>

    <!-- UNSCRAMBLE SECTION - Functionality for restoring scrambled videos -->
    <section class="card">
      <h2>Unscramble a video</h2>
      <div class="row">
        <!-- Input for scrambled video file -->
        <div>
          <label for="shufFile">Upload Scrambled/Shuffled video</label>
          <input id="shufFile" type="file" accept="video/*" />
        </div>
        <!-- JSON parameter input for unscrambling -->
        <!-- <div style="flex:1 1 420px">
          <label for="paramsIn">Paste shuffle parameters (JSON)</label>
          <textarea id="paramsIn" class="mono" placeholder='{"seed":12345,"n":3,"m":3,"perm1based":[3,2,5,1,7,6,9,4,8]}'></textarea>
          
        </div> -->
      </div>

      <div class="row" style="align-items:flex-start">
        <!-- Alternative Base64 input method -->
        <div style="flex:1 1 420px">
          <label for="b64In"> Paste the KEY CODE here:</label>
          <textarea id="b64In" class="mono"
            placeholder="eyJzZWVkIjoxMjM0NSwibiI6MywibSI6MywicGVybTFiYXNlZCI6WzMsMiw1LDEsNyw2LDksNCw4XX0="></textarea>
          <!-- <div class="row">
            <button id="decodeB64" class="btn">Decode ‚Üí Key</button>
          </div> -->
          <div class="row">
            Step 1: <button id="decodeB64" class="btn">Decode ‚Üí Key</button>
            Step 2: <button id="applyParams" class="btn">Apply & Preview</button>
            <!-- When clicked opens the unscrambled video modal -->
            Step 3: <button id="watchUnscrambledVideo" class="btn">Watch Unscrambled Video</button>
            <!-- Step 3: <button id="recordUnscrambled" class="btn">üé¨ Download Unscrambled Video</button> -->
          </div>
          <!-- <div class="hint small">We accept 1‚Äëbased arrays where <span class="mono">arr[dest]</span> gives the <b>source</b> cell index. Example for 3√ó3: <span class="mono">[3,2,5,1,7,6,9,4,8]</span>.</div> -->
        </div>
      </div>

      <div class="sep"></div>

      <!-- Video comparison display for unscrambling -->
      <div class="media-row">
        <!-- Shuffled video display -->
        <div>
          <div class="hint">Scrambled Video</div>
          <video id="shufVideo" style="min-height: 180px;" controls playsinline></video>
        </div>
        <!-- Restored/unscrambled canvas -->
        <div>
          <div class="hint">Unscrambled Video Preview</div>
          <canvas id="unscrambleCanvas" ></canvas>

        </div>
      </div>
    </section>

    <!-- Footer with technical documentation -->
    <!-- <footer class="hint small">Permutation semantics: we export <span class="mono">perm1based</span> where the
      <b>index</b> is the destination tile (1‚Äëbased), and the <b>value</b> is the source tile index (1‚Äëbased). Shuffle
      draws <span class="mono">dest[i] = src[perm[i]]</span>. Unscramble uses the inverse mapping to restore original
      order.</footer> -->
  </div>



  <!-- View Unscrambled Video Modal (75% fullscreen) -->
  <div id="watchUnscramVidDiv" class="ad-modal" style="display:none;">
    <div id="watchUnscramModalContent" class="ad-modal-content1"
      style="width:85vw;  max-width:1200px; max-height:90vh;">
      <div class="ad-title">üé• Watch Unscrambled Video</div>
      <div class="ad-description">Here is your unscrambled video preview. You can play/pause, seek thru the video, and adjust the volume.</div>
      <div class="ad-video" style="height:70%;">

        <canvas id="unscrambleModalCanvas"
          style="width:100%; background:#0b1020; border-radius:12px;"></canvas>
      </div>
      <div class="ad-content" style="height:30%;">
        <div>

          <div class="unscrambled-video-controls" style="display:flex; flex-direction:column; gap:12px;">
            <div class="row" style="flex-direction:row; align-items:center; gap:14px; margin-top:12px;">
              <button id="modalPlayPause" class="btn" style="align-self:center;">Play</button>
              <label for="modalSeekBar" style="margin:0;">Seeker</label>
              <input type="range" id="modalSeekBar" value="0" min="0" max="100" style="width:40%; margin:0;" />
              <label for="modalVolumeBar" style="margin:0;">Volume</label>
              <input type="range" id="modalVolumeBar" value="100" min="0" max="100" style="width:15%; margin:0;" />
            </div>
          </div>
          <button id="closeUnscramModal" class="btn-accent" style="margin-top:18px; margin-right: 0; margin-left: auto;">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Ad Modal -->
  <div id="adModal" class="ad-modal">
    <div id="adModalContent" class="ad-modal-content">
      <!-- Embedded Video Ad Section -->
      <div class="ad-video">
        <!-- Placeholder for embedded video ad -->
        <iframe id="adVideoFrame" width="100%" height="100%" frameborder="0" allowfullscreen
          allow="autoplay; encrypted-media" style="border-radius: 12px;">
        </iframe>
        <!-- <canvas id="unscrambleCanvas"></canvas> -->
      </div>

      <!-- Ad Content Info -->
      <div class="ad-content">
        <div>
          <div class="ad-title">üé• Processing Your Video...</div>
          <div class="ad-description">Your unscrambled video is being generated. Please watch this short message while
            we prepare your download.</div>
        </div>

        <div class="ad-controls">
          <div class="ad-timer" id="adTimer">Please wait...</div>
          <button id="adCloseBtn" class="ad-close-btn">Continue</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========== UTILITY FUNCTIONS ==========

    // hide video when step 3: button is clicked

    // Clamp value between min and max bounds
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    // ========== AD MODAL FUNCTIONALITY ==========

    // Modal state variables
    let isModalOpen = false;
    let adTimer = null;
    let recordingFinished = false;
    let waitTimeRemaining = 10; // 10 seconds additional wait after recording

    // Modal DOM elements (using standard DOM methods)
    const adModal = document.getElementById('adModal');
    const adModalContent = document.getElementById('adModalContent');
    const adVideoFrame = document.getElementById('adVideoFrame');
    const adTimerDisplay = document.getElementById('adTimer');
    const adCloseBtn = document.getElementById('adCloseBtn');

    /**
     * Detect if device is mobile based on screen aspect ratio
     * @returns {boolean} True if mobile layout should be used
     */
    function isMobileLayout() {
      const aspectRatio = window.innerWidth / window.innerHeight;
      return aspectRatio < (10 / 16); // Less than 10:16 ratio = mobile
    }

    /**
     * Show the ad modal with appropriate layout
     * @param {string} adUrl - URL of the video ad to embed
     */
    function showAdModal(adUrl = '') {
      isModalOpen = true;
      recordingFinished = false;
      waitTimeRemaining = 15;

      // Set modal layout based on screen size
      adModalContent.className = 'ad-modal-content ' + (isMobileLayout() ? 'mobile' : 'desktop');

      // Set ad video source (you can customize this)
      if (adUrl) {
        adVideoFrame.src = adUrl;
      } else {
        // Default placeholder ad (you can replace with actual ad URL)
        adVideoFrame.src = 'about:blank';
        adVideoFrame.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
      }

      // Show modal
      adModal.classList.add('show');

      // Disable close button initially
      adCloseBtn.classList.remove('enabled');
      adTimerDisplay.textContent = 'Unscrambling video...';

      // Start timer to track recording progress
      setTimeout(() => {
        
        startAdTimer();
      }, 5000); //  finish after 5 seconds
      
    }

    /**
     * Hide the ad modal
     */
    function hideAdModal() {
      isModalOpen = false;
      adModal.classList.remove('show');
      if (adTimer) {
        clearInterval(adTimer);
        adTimer = null;
      }
    }

    /**
     * Start the ad timer and countdown
     */
    function startAdTimer() {
      if (adTimer) clearInterval(adTimer);

      adTimer = setInterval(() => {
       if (waitTimeRemaining > 0) {
          adTimerDisplay.textContent = `Please wait ${waitTimeRemaining} seconds...`;
          waitTimeRemaining--;
        } else {
          // Enable close button
          adCloseBtn.classList.add('enabled');
          adTimerDisplay.textContent = 'Ready! You can close this window.';
          clearInterval(adTimer);
          adTimer = null;
        }
      }, 1000);
    }

    /**
     * Mark recording as finished and start countdown
     */
    function markRecordingFinished() {
      recordingFinished = true;
      waitTimeRemaining = 10; // Reset to 10 seconds
    }

    // Close button handler
    adCloseBtn.addEventListener('click', () => {
      if (adCloseBtn.classList.contains('enabled')) {
        hideAdModal();
      }
    });

    // Prevent closing modal by clicking outside unless enabled
    adModal.addEventListener('click', (e) => {
      if (e.target === adModal && adCloseBtn.classList.contains('enabled')) {
        hideAdModal();
      }
    });

    /**
     * Mulberry32 - Simple seeded pseudo-random number generator
     * Provides deterministic randomization based on seed value
     * @param {number} a - Initial seed value
     * @returns {function} Random number generator function (0-1 range)
     */
    function mulberry32(a) {
      return function () {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    /**
     * Generate a cryptographically secure random seed if available,
     * fallback to Math.random for compatibility
     * @returns {number} Random 32-bit unsigned integer seed
     */
    function genRandomSeed() {
      if (window.crypto?.getRandomValues) {
        const buf = new Uint32Array(1); window.crypto.getRandomValues(buf); return buf[0] >>> 0;
      }
      return Math.floor(Math.random() * 2 ** 32) >>> 0;
    }

    /**
     * Create a Fisher-Yates shuffled permutation array
     * Maps destination indices to source indices (0-based)
     * @param {number} size - Number of elements to permute
     * @param {number} seed - Seed for deterministic randomization
     * @returns {Array<number>} Permutation array where index=destination, value=source
     */
    function seededPermutation(size, seed) {
      const rand = mulberry32(seed >>> 0);
      const srcs = Array.from({ length: size }, (_, i) => i);
      // Fisher‚ÄìYates shuffle on the source list, then interpret as dest->src assignment
      for (let i = size - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [srcs[i], srcs[j]] = [srcs[j], srcs[i]];
      }
      return srcs; // dest index i will take from source srcs[i]
    }

    // Array conversion utilities for 1-based vs 0-based indexing
    function oneBased(a) { return a.map(x => x + 1); }
    function zeroBased(a) { return a.map(x => x - 1); }

    /**
     * Calculate optimal grid dimensions (n√óm) for given aspect ratio
     * Finds the grid size that produces the most square-like cells
     * @param {number} w - Width of the video/canvas
     * @param {number} h - Height of the video/canvas  
     * @returns {Object} Grid dimensions {n: rows, m: columns}
     */
    function autoGridForAspect(w, h) {
      // Choose n (rows), m (cols) in [2..10] minimizing |(w/m)/(h/n) - 1|
      let best = { n: 2, m: 2, score: Infinity };
      for (let n = 2; n <= 10; n++) {
        for (let m = 2; m <= 10; m++) {
          const cellAspect = (w / m) / (h / n);
          const score = Math.abs(cellAspect - 1); // How far from square (1.0 ratio)
          if (score < best.score) best = { n, m, score };
        }
      }
      return { n: best.n, m: best.m };
    }

    /**
     * Convert scramble parameters to JSON format for export/saving
     * @param {number} seed - Random seed used for permutation
     * @param {number} n - Number of rows in grid
     * @param {number} m - Number of columns in grid
     * @param {Array<number>} permDestToSrc0 - 0-based permutation array
     * @returns {Object} JSON-serializable parameters object
     */
    function paramsToJSON(seed, n, m, permDestToSrc0) {
      return {
        version: 2,
        seed: Number(seed),
        n: Number(n),
        m: Number(m),
        perm1based: oneBased(permDestToSrc0),
        semantics: "Index = destination cell (1-based), value = source cell index (1-based)"
      };
    }

    /**
     * Parse and validate JSON parameters for unscrambling
     * Converts from 1-based to 0-based indexing and validates structure
     * @param {Object} obj - Parsed JSON object with scramble parameters
     * @returns {Object} Validated parameters {n, m, permDestToSrc0}
     * @throws {Error} If parameters are invalid or malformed
     */
    function jsonToParams(obj) {
      const n = Number(obj.n), m = Number(obj.m);
      let perm = null;
      // Support both 1-based and 0-based permutation formats
      if (Array.isArray(obj.perm1based)) perm = zeroBased(obj.perm1based);
      else if (Array.isArray(obj.perm0based)) perm = obj.perm0based.slice();

      // Validation checks
      if (!n || !m || !perm) throw new Error("Invalid params JSON: need n, m, and perm array (perm1based or perm0based)");
      if (perm.length !== n * m) throw new Error("Permutation length doesn't match n*m");

      // Validate it's a valid permutation of 0..N-1
      const seen = new Set(perm);
      if (seen.size !== perm.length || Math.min(...perm) !== 0 || Math.max(...perm) !== perm.length - 1)
        throw new Error("Permutation must contain each index 0..n*m-1 exactly once");
      return { n, m, permDestToSrc0: perm };
    }

    /**
     * Calculate inverse permutation mapping
     * If input maps A->B, output maps B->A
     * @param {Array<number>} arr - Original permutation array
     * @returns {Array<number>} Inverse permutation array
     */
    function inversePermutation(arr) {
      const inv = new Array(arr.length);
      for (let i = 0; i < arr.length; i++) inv[arr[i]] = i;
      return inv;
    }

    /**
     * Generate rectangle coordinates for grid cells
     * Divides given dimensions into n√óm rectangular regions
     * @param {number} w - Total width to divide
     * @param {number} h - Total height to divide
     * @param {number} n - Number of rows
     * @param {number} m - Number of columns
     * @returns {Array<Object>} Array of rectangles with {x,y,w,h} properties
     */
    function cellRects(w, h, n, m) {
      const rects = [];
      const cw = w / m, ch = h / n; // Cell width and height
      for (let r = 0; r < n; r++) {
        for (let c = 0; c < m; c++) {
          rects.push({ x: c * cw, y: r * ch, w: cw, h: ch });
        }
      }
      return rects;
    }

    /**
     * Trigger download of a blob as a file
     * Creates temporary download link and automatically clicks it
     * @param {string} filename - Name for the downloaded file
     * @param {Blob} blob - Data to download
     */
    function download(filename, blob) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename; a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 2500); // Cleanup after download
    }

    // Base64 encoding/decoding utilities for UTF-8 strings
    function toBase64(str) { return btoa(unescape(encodeURIComponent(str))); }
    function fromBase64(b64) { return decodeURIComponent(escape(atob(b64.trim()))); }


    // ========== UNSCRAMBLER SECTION ==========

    // DOM element references for unscrambling interface  
    const shufFile = document.getElementById('shufFile');           // Scrambled video file input
    const shufVideo = document.getElementById('shufVideo');         // Scrambled video element
    // const paramsIn = document.getElementById('paramsIn');           // JSON parameters input
    let paramsIn;            // JSON parameters input
    const b64In = document.getElementById('b64In');                 // Base64 parameters input
    const decodeB64 = document.getElementById('decodeB64');         // Decode Base64 button
    const applyParams = document.getElementById('applyParams');     // Apply parameters button
    const unCanvas = document.getElementById('unscrambleCanvas');   // Unscrambled output canvas
    const unCtx = unCanvas.getContext('2d');   // Canvas rendering context
    const recordUnscrambled = document.getElementById('recordUnscrambled'); // Record unscrambled video button

    // Unscrambler state variables
    let un = { n: 3, m: 3, permDestToSrc0: [0, 1, 2, 3, 4, 5, 6, 7, 8] }; // Unscramble parameters
    let unRectsDest = [], unRectsSrcFromShuffled = [];              // Rectangle arrays
    let unAnimating = false;                                      // Animation state flag
    let unRecorder = null, unChunks = [];          // Video recording state

    // Handle scrambled video file selection
    shufFile.addEventListener('change', () => {
      const f = shufFile.files?.[0]; if (!f) return;
      shufVideo.src = URL.createObjectURL(f);
    });

    // Setup canvas when scrambled video loads
    shufVideo.addEventListener('loadedmetadata', () => {
      // Match canvas size to video resolution
      unCanvas.width = shufVideo.videoWidth;
      unCanvas.height = shufVideo.videoHeight;

      // Build rectangles if parameters are already set
      if (un.n && un.m) {
        buildUnscrambleRects();
      }
    });

    // Decode Base64 parameters to JSON
    decodeB64.addEventListener('click', () => {
      try {
        const json = fromBase64(b64In.value);
        console.log('Decoded JSON:', json);
        paramsIn = json;
      } catch (e) { alert('Invalid Base64 JSON: ' + e.message); }
    });

    // Parse and apply JSON parameters for unscrambling
    applyParams.addEventListener('click', () => {
      try {
        const obj = JSON.parse(paramsIn);
        const { n, m, permDestToSrc0 } = jsonToParams(obj);
        alert(`Applying parameters: n=${n}, m=${m}`);
        // Apply the unscrambling parameters
        un.n = n; un.m = m; un.permDestToSrc0 = permDestToSrc0;
        buildUnscrambleRects();
        // Play video if paused
        if (shufVideo.paused) {
          shufVideo.play()
          setTimeout(() => shufVideo.pause(), 10);
        }

      } catch (e) { alert('Invalid JSON: ' + e.message); }
    });

    /**
     * Build rectangle arrays for unscrambling process
     * Creates mapping from original tile positions to their shuffled locations
     */
    function buildUnscrambleRects() {
      // Destination rectangles on canvas (original order)
      unRectsDest = cellRects(unCanvas.width, unCanvas.height, un.n, un.m);

      // Calculate inverse mapping: where did each original tile end up?
      // permDestToSrc maps DEST->SRC, we need SRC->DEST for unscrambling
      un.srcToDest = inversePermutation(un.permDestToSrc0);

      // Source rectangles from shuffled video
      unRectsSrcFromShuffled = cellRects(shufVideo.videoWidth, shufVideo.videoHeight, un.n, un.m);
    }

    /**
     * Draw a single unscrambled frame to the canvas
     * Maps each original tile position to its location in the shuffled video
     */
    function drawUnscrambledFrame() {
      if (!shufVideo.videoWidth || !un.srcToDest) return;
      unCtx.clearRect(0, 0, unCanvas.width, unCanvas.height);
      const N = un.n * un.m;

      // For each original tile position, find where it is in the shuffled video
      for (let origIdx = 0; origIdx < N; origIdx++) {
        const shuffledDestIdx = un.srcToDest[origIdx]; // Where this tile ended up after scrambling
        const sR = unRectsSrcFromShuffled[shuffledDestIdx]; // Read from shuffled location
        const dR = unRectsDest[origIdx];                    // Draw to original position
        if (!sR || !dR) continue;
        unCtx.drawImage(shufVideo, sR.x, sR.y, sR.w, sR.h, dR.x, dR.y, dR.w, dR.h);
      }
    }

    /**
     * Animation loop for unscrambled video playback
     * Continuously redraws unscrambled frames while video is playing
     */
    function animUnscramble() {
      if (!unAnimating) return;
      if (!shufVideo.paused && !shufVideo.ended) drawUnscrambledFrame();
      requestAnimationFrame(animUnscramble);
    }

    // Video event handlers for unscrambler animation control
    shufVideo.addEventListener('play', () => {
      unAnimating = true;
      animUnscramble();
      // Start recording automatically if user requested it
      if (unRecorder && unRecorder.state === 'inactive') {
        unRecorder.start();
      }
    });
    shufVideo.addEventListener('pause', () => { unAnimating = false; });
    shufVideo.addEventListener('ended', () => {
      unAnimating = false;
      // Stop recording automatically when video ends
      if (unRecorder && unRecorder.state === 'recording') {
        unRecorder.stop();
      }
    });
    shufVideo.addEventListener('seeked', () => { if (!shufVideo.paused) drawUnscrambledFrame(); });

    // // Automatic video recording functionality for unscrambled output (WebM format)
    // recordUnscrambled.addEventListener('click', () => {
    //   if (unRecorder) {
    //     console.warn('Already set up for recording');
    //     return;
    //   }

    //   if (!shufVideo.src) {
    //     alert('Please select a scrambled video first');
    //     return;
    //   }

    //   if (!un.permDestToSrc0 || un.permDestToSrc0.length === 0) {
    //     alert('Please apply scramble parameters first');
    //     return;
    //   }

    //   // Show ad modal first
    //   showAdModal(); // You can pass a custom ad URL here: showAdModal('https://your-ad-url.com')

    //   shufVideo.play(); // Play video to prepare for recording

    //   // Setup recording parameters (reuses FPS from scrambler section)
    //   const fps = clamp(30, 1, 60);
    //   const stream = unCanvas.captureStream(fps);
    //   unChunks = [];

    //   // Create MediaRecorder for unscrambled canvas
    //   unRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
    //   unRecorder.ondataavailable = e => { if (e.data.size) unChunks.push(e.data); };
    //   unRecorder.onstop = () => {
    //     const blob = new Blob(unChunks, { type: 'video/webm' });
    //     download('unscrambled.webm', blob);
    //     unRecorder = null; unChunks = [];
    //     recordUnscrambled.textContent = 'üé¨ Record Unscrambled Video';
    //     recordUnscrambled.disabled = false;

    //     // Mark recording as finished to start countdown
    //     markRecordingFinished();
    //   };

    //   // Update button state
    //   recordUnscrambled.textContent = 'üé• Ready - Click play to start recording';
    //   recordUnscrambled.disabled = true;

    //   // Reset video to beginning 
    //   shufVideo.currentTime = 0;

    //   // Show instructions instead of auto-playing
    //   alert('Recording is ready! Please click the play button on the scrambled video to start recording. The modal will show your progress.');
    // });

    // Modal DOM references
    const watchUnscramVidDiv = document.getElementById('watchUnscramVidDiv');
    const watchUnscramModalContent = document.getElementById('watchUnscramModalContent');
    const unscrambleModalCanvas = document.getElementById('unscrambleModalCanvas');
    const modalPlayPause = document.getElementById('modalPlayPause');
    const modalSeekBar = document.getElementById('modalSeekBar');
    const modalVolumeBar = document.getElementById('modalVolumeBar');
    const closeUnscramModal = document.getElementById('closeUnscramModal');

    // Show modal when Step 3 button is clicked
    document.getElementById('watchUnscrambledVideo').addEventListener('click', () => {
      // Check if video and parameters are ready
      if (!shufVideo.src) {
        alert('Please select a scrambled video first');
        return;
      }
      if (!un.permDestToSrc0 || un.permDestToSrc0.length === 0) {
        alert('Please apply scramble parameters first (Step 2)');
        return;
      }

      showAdModal()

      // Match modal canvas size to video
      unscrambleModalCanvas.width = shufVideo.videoWidth;
      unscrambleModalCanvas.height = shufVideo.videoHeight;

      // Show modal
      watchUnscramVidDiv.style.display = 'flex';

      // Draw initial frame and sync controls
      drawUnscrambledFrameModal();
      syncModalControls();

      // If video is already playing, start animation loop
      if (!shufVideo.paused) {
        modalAnimLoop();
      }
    });

    // Draw unscrambled frame to modal canvas
    function drawUnscrambledFrameModal() {
      const ctx = unscrambleModalCanvas.getContext('2d');
      if (!shufVideo.videoWidth || !un.srcToDest) return;
      ctx.clearRect(0, 0, unscrambleModalCanvas.width, unscrambleModalCanvas.height);
      const N = un.n * un.m;
      for (let origIdx = 0; origIdx < N; origIdx++) {
        const shuffledDestIdx = un.srcToDest[origIdx];
        const sR = unRectsSrcFromShuffled[shuffledDestIdx];
        const dR = unRectsDest[origIdx];
        if (!sR || !dR) continue;
        ctx.drawImage(shufVideo, sR.x, sR.y, sR.w, sR.h, dR.x, dR.y, dR.w, dR.h);
      }
    }

    // Sync modal controls with video
    function syncModalControls() {
      modalSeekBar.max = Math.floor(shufVideo.duration || 100);
      modalSeekBar.value = Math.floor(shufVideo.currentTime || 0);
      modalVolumeBar.value = Math.floor((shufVideo.volume || 1) * 100);
      modalPlayPause.textContent = shufVideo.paused ? 'Play' : 'Pause';
    }

    // Play/Pause button
    modalPlayPause.addEventListener('click', () => {
      if (shufVideo.paused) {
        shufVideo.play();
      } else {
        shufVideo.pause();
      }
    });

    // Seek bar
    modalSeekBar.addEventListener('input', () => {
      shufVideo.currentTime = modalSeekBar.value;
      drawUnscrambledFrameModal();
    });

    // Volume bar
    modalVolumeBar.addEventListener('input', () => {
      shufVideo.volume = modalVolumeBar.value / 100;
    });

    // Update modal canvas on video events (remove duplicate video calls)
    shufVideo.addEventListener('play', () => {
      modalPlayPause.textContent = 'Pause';
      modalAnimLoop(); // Start the animation loop
    });
    shufVideo.addEventListener('pause', () => {
      modalPlayPause.textContent = 'Play';
      // Animation loop will automatically stop when video is paused
    });
    shufVideo.addEventListener('seeked', () => {
      drawUnscrambledFrameModal();
      syncModalControls();
    });
    shufVideo.addEventListener('timeupdate', () => {
      modalSeekBar.value = Math.floor(shufVideo.currentTime);
    });

    // Animation loop for modal canvas
    function modalAnimLoop() {
      // Check if modal is still open
      if (!watchUnscramVidDiv.style.display || watchUnscramVidDiv.style.display === 'none') return;

      // Draw frame if video is playing
      if (!shufVideo.paused && !shufVideo.ended) {
        drawUnscrambledFrameModal();
      }

      // Continue animation loop if video is still playing
      if (!shufVideo.paused && !shufVideo.ended) {
        requestAnimationFrame(modalAnimLoop);
      }
    }

    // Close modal
    closeUnscramModal.addEventListener('click', () => {
      watchUnscramVidDiv.style.display = 'none';
      shufVideo.pause();
    });

    // Close modal on outside click
    watchUnscramVidDiv.addEventListener('click', (e) => {
      if (e.target === watchUnscramVidDiv) {
        watchUnscramVidDiv.style.display = 'none';
        shufVideo.pause();
      }
    });
  </script>
</body>

</html>